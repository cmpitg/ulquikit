= Ulquikit
:Author: Ha-Duong Nguyen (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Current version:

.code::ulquikit-version
[source,lisp,linenums]
----
(defvar *ulquikit-version* "2.0.0")
----

'''

Ulquikit was originally written in Racket using several bootstrap scripts
(also in Racket).  The current version is a complete rewrite in Common Lisp.

For building Ulquikit, the following dependencies are required:

* Ruby 2.1+ with
** http://asciidoctor.org[AsciiDoctor] - AsciiDoc renderer
** https://github.com/tmm1/pygments.rb[pygments.rb] - syntax highlighter
* An ANSI-compliant Common Lisp implementation, preferably
  http://www.sbcl.org[SBCL], with
** https://common-lisp.net/project/asdf[ASDF 3] - build tool
** https://www.quicklisp.org/beta/[Quicklisp] - library manager
** https://github.com/fukamachi/shelly[Shelly] - shelly-friendly interface

For installation of the above software, please consult their official
documentations.  On my setup, I use:

* SBCL 1.2+ with https://github.com/KeenS/CIM[CIM] (Common Lisp Implementation
  Manager)
* Ruby 2.1.3 with https://rvm.io[RVM] (Ruby Version Manager)

== Terminology

* A *code block* is an AsciiDoc code block.

* A *snippet* is a code block with Ulquikit-defined title and delimiter
  `----`.  By default, a code block title that starts `file::` and `code::`
  defines a _file snippet_ and _code snippet_, respectively:

** A *file snippet* is a snippet producing a source file.
** A *code snippet* is a snippet storing source code that can be included into
   other snippets.

* An *include directive* is a line of code that:

** belongs to a snippet
** has the format of `xx include::some-snippet-name` where `xx` are two
   identical characters denoting a comment.  Ulquikit can recogize the
   following comment types: `//`, `;;`, `##`, `--`, or C-stype `/*
   include::some-snippet-name */`, or XML-style `<!--
   include::some-snippet-name -->`.

== Interfaces

Before going into any detail, I would like to define the interfaces that
Ulquikit uses to interact with the outside world as a Common Lisp package.

.code::defpackage-ulquikit
[source,lisp,linenums]
----
(defpackage #:ulquikit
  (:use :cl :alexandria :split-sequence :fiasco)
  (:export #:generate-src
           #:generate-html
           #:snippet))

(in-package #:ulquikit)
----

Along with the main package comes the test one.  I decide to use
https://github.com/capitaomorte/fiasco[Fiasco] since it has very nice
interface and helpful messages.

.code::defpackage-ulquikit-tests
[source,lisp,linenums]
----
(fiasco:define-test-package #:ulquikit-tests
  (:use :cl :ulquikit))
----

== Extracting and including snippets

Ulquikit works by searching for all AsciiDoc documents inside
`<project-root>/src` directory, building a database of snippets, including
them into each other if necessary, then generating documentation and source
code.  Hence, the following functions are probably the most interesting ones:

* <<func/extract-snippets-from-file,`extract-snippets-from-file`>>, which
  helps extract snippets from a file
* <<func/include-snippet,`include-snippet`>>, which helps
  <<section/include-snippets,include snippets>> into each other

Let's talk about `extract-snippets-from-file` first:

=== Extracting snippets

First, we need to decide how snippets are stored.  This is very important as
every change made to this data structure would affect the code later on.

Each snippet is struct with following alist representation:

[[snippet-format]]
[source,lisp]
----
`((:type       . ,snippet-type)  <1>
  (:name       . ,snippet-name)  <2>
  (:linenum    . ,line-number)   <3>
  (:lines      . ,snippet-lines) <4>
  (:processed? . ,processed?))   <5>
----
<1> is either `:file` or `:code`
<2> is the name of the snippet; e.g. snippet with title `file::something` has `something` as its name.  Note that snippet name is _a string_.
<3> is the line number from the literate source code from where the snippet is extracted
<4> is the content of the snippet as a list of lines, necessary for performance purpose
<5> determines whether this snippet has been processed? to include others, when created for the first time, `'processed?` is always `#f`.  It's only changed after the snippet has been passed through <<include-snippet,+include-snippet+>>

Thus, a struct representation of a snippet is defined as followed:

.code::define-snippet
[source,lisp,linenums]
----
(defstruct snippet
  (type :code     :type keyword)
  (name ""        :type string)
  (linenum 0      :type integer)
  (lines (list)   :type list)
  (processed? nil :type boolean))
----

IMPORTANT: Snippets should never be created by directly by using
`make-snippet`.  They should be created with
<<func/create-snippet,`create-snippet`>>.

Since a snippet stores a list of lines as its content, it'd be convenient to
have a helper that joins those lines into a complete string:

.code::get-snippet-content
[source,lisp,linenums]
----
(defun get-snippet-content (snippet)
  "Returns the content of a snippet, i.e. all of its lines are joined by
newline characters."
  (declare (type (snippet snippet)))
  (format nil "~{~A~^~%~}" (snippet-lines snippet)))
----

`create-snippet` is simply implemented as followed:

anchor:func/create-snippet[]
.code::create-snippet
[source,lisp,linenums]
----
;; include::get-snippet-content

(defun create-snippet (&key type name linenum lines (processed? nil))
  "Helper to create snippet."
  (let ((type (->keyword type))
        (name (->string name))
        (lines (if (stringp lines)
                   (split-sequence #\Newline lines)
                 lines)))
    (the snippet (make-snippet :type type
                               :name name
                               :linenum linenum
                               :lines lines
                               :processed? processed?))))

(module+ test
  (check-equal? (create-snippet #:type 'file
                                #:name 'hello-world
                                #:linenum 10
                                #:lines '("Hmm"))
                {'type 'file
                 'name "hello-world"
                 'linenum 10
                 'lines '("Hmm")
                 'processed? #f})
  (check-equal? (create-snippet #:type "string"
                                #:name "string"
                                #:linenum 100
                                #:lines "string")
                {'type 'string
                 'name "string"
                 'linenum 100
                 'lines '("string")
                 'processed? #f}))

----

Now the helper +create-snippet+ is ready.  Let's move on to
+extract-snippets-from-file+.

+extract-snippets-from-file+ needs to determine whether _a line in a code
block_ belongs to a _code snippet_, or _file snippet_, or none of those; then
extracts the content of the code block and store it if necessary.  Let's have
a look at 3 types of code block to see how we could tackle this problem:

* A _code snippet_ has the following format:
+
[listing]
..........
.code::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.code::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........


* A _file snippet_ shares the same structure as a _code snippet_:
+
[listing]
..........
.file::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.file::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........


* A non-snippet code block is any block without +code::...+ or +file::...+ as
  its title:
+
[listing]
..........
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>

....                            <3>
This is a literal block
....                            <4>
..........

<1> block title
<2> block type
<3> block delimiter
<4> block delimiter

As we can clearly see from the 3 examples, _code snippets_ and _file snippets_
could be determined by checking 2^nd^ previous line from block delimiter to
see if it starts with +.file::+ or +.code::+.  Everything between the 2
delimiters is stored as the content of the snippet.

Hence, we have the following algorithm for +extract-snippets-from-file+:

* Read the content of a file

* Break the content into lines preserving line numbers (call +string-split+
  with +#:trim? #f+).

* For each line:

** If we're already inside a snippet:

*** Complete a snippet and add it to snippet list if current line is a block
    delimiter (i.e. +----+)

*** Add current line to the current snippet's content if current line is not a
    block delimiter

** If we're outside a snippet, we only care if current line is a block
   delimiter (i.e. +----+):

*** If this block has a title that marks the beginning of a snippet (i.e. the
    2^nd^ previous line starts with +.file::+ or +.code::+), extract snippet
    name and add a new snippet.  Otherwise

*** If this block does not mark the beginning of a snippet, ignore it.

[[func/extract-snippets-from-file]]
.code::extract-snippets-from-file
[source,racket,linenums]
----
;; include::extract-snippets-from-file-helpers

(define (extract-snippets-from-file path)
  (let* ([file-content (read-file path)]
         [lines        (string-split file-content "\n" #:trim? #f)]

         [snippets        (box {'file {}
                                      'code {}})]

         [prev-prev-line  (box "")]
         [prev-line       (box "")]

         [snippet-type    (box null)]
         [snippet-lines   (box '())]
         [snippet-name    (box "")]
         [snippet-linenum (box 0)]
         [inside-snippet  (box #f)])

    (for ([line-num    (in-naturals 1)]
          [line        (in-list lines)])

      (cond [(and (unbox inside-snippet)
                  (not (is-block-delimiter? line)))

             (box-swap! snippet-lines append (list line))]

            [(and (unbox inside-snippet)
                  (is-block-delimiter? line))

             (box-set! inside-snippet #f)
             (box-swap! snippets
                        add-snippets
                        (create-snippet #:type (unbox snippet-type)
                                        #:name (unbox snippet-name)
                                        #:linenum (unbox snippet-linenum)
                                        #:lines (unbox snippet-lines)))]
            [(is-block-delimiter? line)

             (when (or (is-block-title? (unbox prev-prev-line))
                       (is-block-title? (unbox prev-line)))
               (let ([title-line (if (is-block-title? (unbox prev-prev-line))
                                     (unbox prev-prev-line)
                                     (unbox prev-line))])
                 (box-set! inside-snippet #t)

                 (box-set! snippet-type (get-snippet-type title-line))
                 (box-set! snippet-name (get-snippet-name title-line))
                 (box-set! snippet-lines '())
                 (box-set! snippet-linenum (dec line-num))))])

      ;; Always update previous line
      (box-set! prev-prev-line (unbox prev-line))
      (box-set! prev-line      line))

    (unbox snippets)))

----

Of course, for +extract-snippets-from-file+ to function, the following helpers are
necessary:

.code::extract-snippets-from-file-helpers
[source,racket,linenums]
----
(define is-block-delimiter?
  #λ(regexp-match? #rx"^----( *)$" %))

(module+ test
  (check-equal? (is-block-delimiter? "----")    #t)
  (check-equal? (is-block-delimiter? " ----")   #f)
  (check-equal? (is-block-delimiter? "---- ")   #t)
  (check-equal? (is-block-delimiter? "----  ")  #t)
  (check-equal? (is-block-delimiter? "----a")   #f))

(define is-block-title?
  #λ(regexp-match? #rx"^\\.(file|code)::" %))

(module+ test
  (check-equal? (is-block-title? ".file::something")       #t)
  (check-equal? (is-block-title? ".file::something else")  #t)
  (check-equal? (is-block-title? ".file::")                #t)
  (check-equal? (is-block-title? ".file:something")        #f))

(define get-snippet-type
  #λ(~> (string-rest %)
      (string-split "::")
      (list-ref 0)
      string->symbol))

(module+ test
  (check-equal? (get-snippet-type ".file::")  'file)
  (check-equal? (get-snippet-type ".code::")  'code))

(define get-snippet-name
  #λ(~> (string-rest %)
      (string-split "::")
      (append '(""))
      (list-ref 1)))

(module+ test
  (check-equal? (get-snippet-name ".file::")     "")
  (check-equal? (get-snippet-name ".code::")     "")
  (check-equal? (get-snippet-name ".file::abc")  "abc")
  (check-equal? (get-snippet-name ".code::a b")  "a b"))

(define (add-snippets snippets snippet)
  (let* ([type (snippet 'type)]
         [name (snippet 'name)]

         [snippets/typed         (snippets type)]
         [snippets/typed/updated (snippets/typed name snippet)])
    (snippets type snippets/typed/updated)))

(module+ test
  (check-equal? (add-snippets {'file {}
                               'code {}}
                              (create-snippet #:type 'file
                                              #:name 'hello
                                              #:linenum 10
                                              #:lines '("Something")))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'lines '("Something")
                                 'processed? #f}}
                 'code {}})

  (check-equal? (add-snippets {'file {"hello" {'type 'file
                                               'name "hello"
                                               'linenum 10
                                               'lines '("Something")
                                               'processed? #f}}
                               'code {}}
                              (create-snippet #:type 'code
                                              #:name 'say-something
                                              #:linenum 100
                                              #:lines '("Something else")))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'lines '("Something")
                                 'processed? #f}}
                 'code {"say-something" {'type 'code
                                         'name "say-something"
                                         'linenum 100
                                         'lines '("Something else")
                                         'processed? #f}}}))

----

As a result, +extract-snippets+, which extracts snippets from all AsciiDoc
documents in a directory recursively, makes use of
+extract-snippets-from-file+ to function.  +extract-snippets+ takes a path and
return a hash of following format:

[source,racket]
----
{'file file-snippets-hash
 'code code-snippets-hash}
----

+file-snippets-hash+ and +code-snippets-hash+ follow <<snippet-format,snippet
format>> defined above.

.code::extract-snippets
[source,racket,linenums]
----
;; include::extract-snippets-from-file

(define (extract-snippets from-dir)
  (for/fold ([snippet {}])
      ([file (list-all-adocs (standardize-path from-dir))])
    (dict-merge snippet (extract-snippets-from-file file))))

(module+ test
  (let* ([temp-dir (get-relative-path (get-temp-dir)
                                      "./ulqui-extract-snippets")]

         [expected-code-snippets
          {"main-program" (string-join
                           '(";; include::utils"
                             ""
                             "(module+ main"
                             "  (displayln (string-reverse \"¡Hola mundo!\")))"
                             "")
                           "\n")
           "use-rackjure" (string-join
                           '("#lang rackjure"
                             "(current-curly-dict hash)")
                           "\n")
           "license-header" ";; Just a sample license header."
           "utils" ";; include::utils-string"
           "utils-string" (string-join
                           '("(define (string-reverse str)"
                             "  (~> (string->list str)"
                             "    reverse"
                             "    list->string))")
                           "\n")}]

         [expected-file-snippets
          {"/tmp/tmp.rkt" (string-join
                           '(";; include::license-header"
                             ""
                             ";; include::use-rackjure"
                             ""
                             ";; include::main-program"
                             ""
                             "== Main program"
                             "")
                           "\n")}]

         [file-list '("Main"
                      "License"
                      "inside/Utils"
                      "inside/Utils-String")]
         [source-files (for/list ([name (in-list file-list)])
                         (get-relative-path (format "~a./~a.adoc"
                                                    temp-dir
                                                    name)))]
         [content
          {"Main" (string-join
                   (list "= A document"
                         ""
                         "Just a hello world program"
                         ""
                         "[source,racket,linenums]"
                         ".file::/tmp/tmp.rkt"
                         "----"
                         (expected-file-snippets "/tmp/tmp.rkt")
                         "----"
                         ".code::main-program"
                         "[source,racket,linenums]"
                         "----"
                         (expected-code-snippets "main-program")
                         "----"
                         ".code::use-rackjure"
                         "[source]"
                         "----"
                         (expected-code-snippets "use-rackjure")
                         "----"
                         "")
                   "\n")
           "License" (string-join
                      (list "= License header"
                            ""
                            ".code::license-header"
                            "[source,racket]"
                            "----"
                            (expected-code-snippets "license-header")
                            "----")
                      "\n")
           "inside/Utils" (string-join
                           (list "= Utils"
                                 ""
                                 "Right now, we just want to include string utililities."
                                 ""
                                 ".code::utils"
                                 "[source,racket,linenums]"
                                 "----"
                                 (expected-code-snippets "utils")
                                 "----")
                           "\n")
           "inside/Utils-String" (string-join
                                  (list "= String Utilities"
                                        ""
                                        ".code::utils-string"
                                        "[source,racket,linenums]"
                                        "----"
                                        (expected-code-snippets "utils-string")
                                        "----")
                                  "\n")}])
    (with-handlers ([exn:fail? #λ(remove-dir temp-dir)])
      (remove-dir temp-dir)
      (create-dir (get-relative-path temp-dir
                                     "./inside"))
      (for ([(filename content) (in-hash content)])
        (let ([path (get-relative-path temp-dir
                                       (format "./~a.adoc" filename))])
          (display-to-file content path)))

      (let* ([snippets (extract-snippets temp-dir)]
             [code-snippet (get-code-snippets snippets)]
             [file-snippet (get-file-snippets snippets)])

        (for ([(name snippet) code-snippet])
          (check-equal? (get-snippet-content snippet)
                        (expected-code-snippets name)))

        (for ([(name snippet) file-snippet])
          (check-equal? (get-snippet-content snippet)
                        (expected-file-snippets name))))
      (remove-dir temp-dir))))
----

After +extract-snippets+, the next important function is +include-snippet+,
which is use to include other snippets into one targeted snippet.  Let's see
how we could implement it.

anchor:section/include-snippets[]

=== Including snippets into each other

+include-snippet+ should take 2 arguments: a hash containing all snippets,
and the snippet which needs to be checked and included.  Thus this function
has the following signature: +(include-snippet snippets target)+
+include-snippet+ working by browsing its content, one line at a time, then
replace the line with +include+ directive with the corresponding _code
snippet_.  If no snippet is found, leave that line as-is.

Note that there are a couple things to bring into concern there:

* Snippet A includes snippet B, snippets B includes snippets C and D.  So the
  best scenario is to include C and D into B while we're actually
  processing A.  I.e. +include-snippet+ should be recursive to accumulate the
  results.

* Also because of the above reason, +snippets+ should be able to receive the
  changes across all calls recursive to +include-snippet+.  I.e. consider
  this dummy, incorrect implementation:
+
[source,racket,linenums]
----
(define (include-snippet snippets target)
  (unless (= (snippets 'a) 12)
    ;; Increase (snippets 'a)
    (include-snippet snippets new-target)))

(let ([snippets {'a 10}])
 (include-snippet snippets some-target))

(displayln (snippets 'a))
;; ⇨ 12

----
+
As you can see after returning from any call, the value of snippets should be
changed as it is changed inside those calls.
+
One of the solutions for this is to construct a helper and put +snippets+ into
a +box+ to make it safely immutable, then change it value for each time the
helper is call.

.+box+ and mutability
[TIP]
This is a perfect example of safe use mutable values in combination with
http://docs.racket-lang.org/reference/boxes.html[+box+].

* Snippet A includes snippet B, then snippet B includes snippet A again,
  creating circular dependency.  To prevent this, a list of currently included
  snippet must be kept track of.  If a snippet has already been in the track,
  include it but don't process it.

WARNING: In case of circular dependency, the results are *unexpected*.  Thus,
make sure snippets are well-managed.

Henceforth, our helper will takes the signature: +(process-include-snippet
target track)+

With all the reasons stated above, we have this implementation:

[[func/include-snippet]]
.code::include-snippet
[source,racket,linenums]
----
;; lang racket

;; include::include-snippet-helpers

(define (include-snippet boxed
                         target
                         [included? {}])
  (define updated-included? (included? (target 'name) #t))
  (unless (target 'processed?)
    (let* ([lines
            (for/list ([line (target 'lines)])
              (if (is-include-directive? line)
                  (let* ([included-snippet-name (get-included-snippet-name line)]
                         [snippet-to-include    (get-snippet-by-name (unbox boxed)
                                                                     included-snippet-name)])
                    (cond [(or (updated-included? included-snippet-name)
                               (not snippet-to-include))

                           ;; This snippet has already been included on the
                           ;; track or there's no such snippet ⇨ do nothing
                           line]

                          [(snippet-to-include 'processed?)

                           ;; When the snippet is already processed, simply
                           ;; return it
                           (string-join (snippet-to-include 'lines) "\n")]

                          [else

                           ;; When the snippet we're about to include exists
                           ;; and hasn't been processed
                           (include-snippet boxed
                                            snippet-to-include
                                            (updated-included? included-snippet-name #t))

                           ;; Of course, then we must return it after
                           ;; processed
                           (~> (get-snippet-by-name (unbox boxed)
                                                    included-snippet-name)
                             'lines
                             (string-join "\n"))]))

                  line))]

           [new-snippet (create-snippet #:type (target 'type)
                                        #:name (target 'name)
                                        #:linenum (target 'linenum)
                                        #:lines lines
                                        #:processed? #t)])
      (update-snippet/boxed boxed new-snippet))))

(module+ test
  (let* ([file-snippet-tmp {'name "/tmp/tmp.rkt"
                            'type 'file
                            'lines '(";; include::A")
                            'linenum 10}]
         [snippets {'file {"/tmp/tmp.rkt" file-snippet-tmp}
                    'code {"A" {'name "A"
                                'type 'code
                                'lines '("World" ";; include::B")
                                'linenum 20}
                           "B" {'name "B"
                                'type 'code
                                'lines '("Hello")
                                'linenum 30}
                           "C" {'name "C"
                                'type 'code
                                'lines '("Unprocessed")
                                'linenum 30
                                'processed? #f}}}]
         [boxed (box snippets)])
    (include-snippet boxed file-snippet-tmp {})
    (check-equal? (unbox boxed)
                  {'file {"/tmp/tmp.rkt" {'name "/tmp/tmp.rkt"
                                          'type 'file
                                          'lines '("World\nHello")
                                          'linenum 10
                                          'processed? #t}}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" "Hello")
                               'linenum 20
                               'processed? #t}
                          "B" {'name "B"
                               'type 'code
                               'lines '("Hello")
                               'linenum 30
                               'processed? #t}
                          "C" {'name "C"
                               'type 'code
                               'lines '("Unprocessed")
                               'linenum 30
                               'processed? #f}}}))

  (let* ([snippet-a {'name "A"
                     'type 'code
                     'lines '("World" ";; include::B")
                     'linenum 20}]
         [snippets {'file {}
                    'code {"A" snippet-a
                           "B" {'name "B"
                                'type 'code
                                'lines '("Hello" ";; include::A")
                                'linenum 30}}}]
         [boxed (box snippets)])
    (include-snippet boxed snippet-a {})
    (check-equal? (unbox boxed)
                  {'file {}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" "Hello\n;; include::A")
                               'linenum 20
                               'processed? #t}
                          "B" {'name "B"
                               'type 'code
                               'lines '("Hello" ";; include::A")
                               'linenum 30
                               'processed? #t}}}))

  (let* ([snippet-a {'name "A"
                     'type 'code
                     'lines '("World" ";; include::B")
                     'linenum 20}]
         [snippets {'file {}
                    'code {"A" snippet-a}}]
         [boxed (box snippets)])
    (include-snippet boxed snippet-a {})
    (check-equal? (unbox boxed)
                  {'file {}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" ";; include::B")
                               'linenum 20
                               'processed? #t}}})))

;; (define (include-snippet snippets target)
;;   (let* ([boxed (box snippets)]
;;          [snippet-name (target 'name)])
;;     (include-snippet boxed
;;                              #:name snippet-name
;;                              #:included {})))

----

As we can see, +include-snippet+ makes use of a lot of helpers.  All of them
are short and easily implemented like so:

.code::include-snippet-helpers
[source,racket,linenums]
----
(define (update-snippet/boxed snippets/box snippet)
  (let* ([type (snippet 'type)]
         [name (snippet 'name)])
    (box-swap! snippets/box
               (λ (snippets)
                 (let* ([snippets/typed (snippets type)]
                        [snippets/typed/updated (snippets/typed name snippet)]
                        [snippets/updated (snippets type snippets/typed/updated)])
                   snippets/updated)))))

(module+ test
  (let* ([snippets {'file {}
                    'code {"hello" {'type 'code
                                    'name "hello"
                                    'lines '("original")
                                    'linenum 20
                                    'processed? #f}}}]
         [snippets/box (box snippets)])
    (update-snippet/boxed snippets/box
                          {'type 'code
                           'name "hello"
                           'lines '("changed")
                           'linenum 10
                           'processed? #t})
    (check-equal? (unbox snippets/box)
                  {'file {}
                   'code {"hello" {'type 'code
                                   'name "hello"
                                   'lines '("changed")
                                   'linenum 10
                                   'processed? #t}}})))

(define is-include-directive?
  #λ(or (regexp-match? #px"^[#;/-]{2} include::.*" (string-trim %))
        (regexp-match? #px"^<!-- include::.* -->" (string-trim %))
        (regexp-match? #px"^/\\* include::.* \\*/" (string-trim %))))

(module+ test
  (check-equal? (is-include-directive? "  ;; include::") #t)
  (check-equal? (is-include-directive? ";; include::") #t)
  (check-equal? (is-include-directive? "a;; include::") #f)
  (check-equal? (is-include-directive? ";; include::something") #t)
  (check-equal? (is-include-directive? "## include::something") #t)
  (check-equal? (is-include-directive? "// include::something") #t)
  (check-equal? (is-include-directive? "/* include::something */") #t)
  (check-equal? (is-include-directive? "<!-- include::something -->") #t)
  (check-equal? (is-include-directive? "a <!-- include::something -->") #f))

(define (get-included-snippet-name line)
  (if (is-include-directive? line)
      (let* ([line (string-trim line)]
             [line-2 (if (string-ends-with? line " -->")
                         (first (string-split line " -->"))
                         line)]
             [line-3 (if (string-ends-with? line-2 " */")
                         (first (string-split line-2 " */"))
                         line-2)]
             [splitted (string-split line-3 "include::")])
        (if (> (length splitted) 1)
            (last splitted)
            ""))
      ""))

(module+ test
  (check-equal? (get-included-snippet-name "  ;; include::") "")
  (check-equal? (get-included-snippet-name ";; include::") "")
  (check-equal? (get-included-snippet-name ";; include::something") "something")
  (check-equal? (get-included-snippet-name "## include::something") "something")
  (check-equal? (get-included-snippet-name "// include::something") "something")
  (check-equal? (get-included-snippet-name "/* include::something */") "something")
  (check-equal? (get-included-snippet-name "<!-- include::something -->") "something")
  (check-equal? (get-included-snippet-name "a <!-- include::something -->") ""))

(define (get-snippet-by-name snippets
                             name
                             #:type [type 'code])
  (~> snippets type name))
----

And that concludes the most important functions of Ulquikit.  Those functions
are used to implement the <<section/generate-source,+generate-src+>> right below.

[[command/generate-src]]
== Generating source code

Once snippets are extracted and included into each other, the act of
generateing source code becomes trivial, as implemented in +generate-src+
below.

.code::generate-src
[source,racket,linenums]
----
;; lang racket

;; include::create-snippet

;; include::extract-snippets

;; include::include-snippet

;; include::generate-snippets-helpers

(define (generate-src #:from [from "src"]
                      #:to   [to   "generated-src"])
  (let* ([from (get-path from)]
         [to   (get-path to)])
    (~> (if (file-exists? from)
            (extract-snippets-from-file from)
            (extract-snippets from))
      (include-file-snippets)
      (generate-src-files to))))

----

The ultimate goal of generating source code is to produce files, so we only
need to include other snippets into file snippets.  +include-file-snippets+
does exactly that.  This function takes a hash of snippets as a result of the
call to +extract-snippets+ and returns a hash of snippets with all file
snippets <<section/include-snippets,included>>.  Let's combine the implement
of +include-file-snippets+ and +generate-src-files+ to make a complete set of
helpers for +generate-src+.

.code::generate-snippets-helpers
[source,racket,linenums]
----
;; lang racket

(define (include-file-snippets snippets)
  (let ([boxed (box snippets)]
        [file-snippets/names (hash-keys (get-file-snippets snippets))])
    (for ([target-name file-snippets/names])
      (let* ([target (~> snippets 'file target-name)])
        (include-snippet boxed target {})))
    (unbox boxed)))

(define (generate-src-files snippets to)
  (for ([(name snippet) (get-file-snippets snippets)])
    (let* ([path    (get-path to name)]
           [content (get-snippet-content snippet)])
      (create-dir (path->directory path))
      (displayln (~a "-> Writing " path))
      (display-to-file content path #:exists 'truncate/replace))))

(define get-file-snippets #λ(% 'file #:else {}))

(define get-code-snippets #λ(% 'code #:else {}))

----

And of course, we need to define help string for +generate-src+:

.file::commands/generate-src.help.txt
[source,text,linenums]
----
ulqui generate-src [--from from] [--to to]

Generate source code from literate documents.

  --from   either path to a directory literate documents are stored, or path
           to one literate document; default: "src"
  --to     directory where source code are generated, default: "generated-src"

Examples

Generate source code from src/ to generated-src/
  ulqui generate-src

or explitcitly
  ulqui generate-src --from src/ --to generated-src/

Generate source code from ../literate-source/ to ../source/
  ulqui generate-src --from ../literate-source/ --to ../source/

----

Once all functions are ready, let's put them together into a command to
generate source code.

.file::commands/generate-src.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")

(require "../utils/utils.rkt")
(require "../utils/path.rkt")
(require "../utils/string.rkt")

(provide run)

(module+ test
  (require rackunit))

;; include::generate-src

(define (run #:from [from "src"]
             #:to   [to   "generated-src"])
  (display-command "Generating source")
  (generate-src #:from from
                #:to   to))

----

That's how +generate-src+ should be done.  It's time to generalize this
structure for defining other commands as well.

== Anatomy of a Ulquikit command

Ulquikit commands are actually a Racket modules, residing in +commands/+.  The
name of the module (without +.rkt+ extension of course) is the actual command.
E.g. +commands/generate-src.rkt+ implements +generate-src+ command.

As a rule of thumb, each command has to provide at least 2 functions: +run+
and +help+:

* Command line arguments are parsed and passed through +run+ function.  Named
  arguments are automatically converted to either boolean or number and passed
  as Racket keywords.
+
E.g.

** +ulqui generate-src+ calls ++commands/generate-src++'s +(run)+.
** +ulqui generate-src some-file+ calls ++commands/generate-src++'s +(run "some-file")+.
** +ulqui generate-src --from file1 --to file2+ calls
   ++commands/generate-src++'s +(run #:from "file1" #:to "file2")+.

* When +ulqui help command-name+ or +ulqui command-name --help+ is invoked,
  the +help+ function that belongs to +commands/command-name.rkt+ module is
  called.  The same effect could be achieved by calling +(run #:help #t)+.
  This the +help+ function takes no arguments and returns a string that would
  be displayed as help.

* Usually, in a typical program, help strings are hardcoded into the source
  code, which makes the maintenance of help strings harder that necessary, not
  to mention the code looks really ugly.  Ulquikit defines a convention for
  writing and maintaining helps more effectively: command +do-something+ has
  its help stored in +commands/do-something.help.txt+.  See the implementation
  of <<command/generate-src,+generate-src+>> for more details on
  <<help/generate-src,how help string>> is stored.

* All commands must import +command-core.rkt+ (relative to command directory:
  +../command-core.rkt+).

With all that has been said, let's move on to the function which is used to
parse command line arguments.

=== Parsing command line arguments +parse-command-args+

This function takes all arguments passed to the command line as a list of
string and returns a map of following format:

[source,racket]
----
{'arguments list-of-arguments  <1>
 'options   hash-of-options}   <2>
----
<1> main arguments collected as a list, with the same order as they are at the
command line
<2> options are collected a hash; options that have no values are set to +#t+

[[func/parse-command-args]]
.code::parse-command-args
[source,racket,linenums]
----
;; include::parse-command-args-helpers

(define (parse-command-args args)
  (let ([arguments (takef args is-argument?)]
        [rest-args (dropf args is-argument?)])
    (let parse-options ([rest-args  rest-args]
                        [options    {}])
      (if (empty? rest-args)
          {'arguments arguments
           'options   options}
          (let* ([option-name   (first rest-args)]
                 [option-values (takef (drop rest-args 1) is-argument?)]
                 [rest-args     (dropf (rest rest-args)   is-argument?)]

                 [option-values/converted (map try-convert-value option-values)]

                 [name   (option->keyword option-name)]
                 [values (cond [(zero? (length option-values/converted))
                                #t]
                               [(= (length option-values/converted) 1)
                                (first option-values/converted)]
                               [else
                                option-values/converted])])
            (parse-options rest-args
                           (options name values)))))))

(module+ test
  (check-equal? (parse-command-args '())
                {'arguments '()
                 'options   {}})

  (check-equal? (parse-command-args '("hello-world"))
                {'arguments '("hello-world")
                 'options   {}})

  (check-equal? (parse-command-args '("hello" "world"))
                {'arguments '("hello" "world")
                 'options   {}})

  (check-equal? (parse-command-args '("--help"))
                {'arguments '()
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help"))
                {'arguments '("hello")
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help" "world" "args"))
                {'arguments '("hello")
                 'options   {'#:help '("world" "args")}})

  (check-equal? (parse-command-args '("--help" "hello"))
                {'arguments '()
                 'options   {'#:help "hello"}})

  (check-equal? (parse-command-args '("hello" "world" "--help" "--set-tab" "4"))
                {'arguments '("hello" "world")
                 'options   {'#:help #t
                             '#:set-tab 4}}))

----

As always, it's a good style to implement some helpers for
<<func/parse-command-args,+parse-command-args+>>.

.code::parse-command-args-helpers
[source,racket,linenums]
----
;; #lang racket

(define is-argument? #λ(not (string-starts-with? % "-")))

(module+ test
  (check-equal? (is-argument? "")     #t)
  (check-equal? (is-argument? "a")    #t)
  (check-equal? (is-argument? "-a")   #f)
  (check-equal? (is-argument? "--a")  #f)
  (check-equal? (is-argument? "-")    #f))

(define is-option? #λ(not (is-argument? %)))

(module+ test
  (check-equal? (is-option? "")     #f)
  (check-equal? (is-option? "a")    #f)
  (check-equal? (is-option? "-a")   #t)
  (check-equal? (is-option? "--a")  #t)
  (check-equal? (is-option? "-")    #t))

(define option->keyword
  #λ(string->keyword (~> (string->list %)
                       (dropf (λ (ch) (eq? #\- ch)))
                       list->string)))

(module+ test
  (check-equal? (option->keyword "-h")      '#:h)
  (check-equal? (option->keyword "--help")  '#:help)
  (check-equal? (option->keyword "---help") '#:help))

(define try-convert-value
  #λ(if-let [value (string->number %)]
      value
      (cond [(string=? "true" %)
             #t]
            [(string=? "false" %)
             #f]
            [else
             %])))

(module+ test
  (check-equal? (try-convert-value "1") 1)
  (check-equal? (try-convert-value "a") "a")
  (check-equal? (try-convert-value "true")  #t)
  (check-equal? (try-convert-value "false") #f))

----

=== Calling corresponding command

Function +run-command+ does exactly that, i.e. it calls corresponding command
and passes necessary arguments.

[[func/run-command]]
.code::run-command
[source,racket,linenums]
----
(define (run-command command args)
  (let* ([module-location (string->path
                           (get-path +ulquikit-location+
                                     (format "commands/~a.rkt"
                                             command)))]
         [run-func        (dynamic-require module-location 'run)]
         [args            (if (hash? args)
                              args
                              (parse-command-args args))]
         [main-args       (args 'arguments)]
         [keyword-list    (hash-keys (args 'options))]
         [val-list        (hash-values (args 'options))])
    (if (~> args 'options '#:help)
        (run-help command)
        (with-handlers ([exn:fail:contract?
                         (λ (e)
                           (displayln "=> Invalid option(s)")
                           (displayln e)
                           (newline)
                           (run-help command))])
          (keyword-apply run-func
                         keyword-list
                         val-list
                         main-args)))
    (newline)))

----

Besides <<func/run-command,+run-command+>>, we also have +run-help+ as a
helper to display help of a command.  +run-help+ simply reads the help file of
the corresponding command and returns its content.

.code::run-help
[source,racket,linenums]
----
(define (run-help command)
  (let* ([help-file (get-path +ulquikit-location+
                              (format "commands/~a.help.txt"
                                      command))])
    (displayln (read-file help-file))))

----

=== Putting all command things together

With all necessary functions implemented, module +command-core+ which all
other commands have to +required+ comes down to this little piece below:

.file::command-core.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "ulquikit.rkt")
(require "utils/path.rkt")
(require "utils/string.rkt")

(provide run-command
         (rename-out [run-help run-command-help]
                     [run-help run-help])
         display-command)

(module+ test
  (require rackunit))

(define (display-command title)
  (displayln (str "==== " title " ====")))

;; include::parse-command-args

;; include::run-command

;; include::run-help

----

The next big piece of Ulquikit is the +generate-html+ command which generates
HTML documents with some default options.

== Generating HTML

First, let's decide upon how this command is used:

.file::commands/generate-html.help.txt
[source,text,linenums]
----
Usage: generate-html [--from from] [--to to]

Generate HTMLs from literate documents.

  --from   either path to a directory where literate documents are stored, or
           path to one literate document, default: "src"
            
  --to     directory where HTMLs are generated, default: "generated-html"

Examples

Generate HTMLs from src/ to generated-html/ recursively
  ulqui generate-html

or explicitly
  ulqui generate-html --from src/ --to generated-html/

Generate HTMLs from literate-source/ to generated-documents/
  ulqui generate-html \
    --from literate-source/ \
    --to generated-documents

----

As in other commands, +generate-html+ also has a main function, which is named
+generate-html+ as well, taking 2 optional directories: source (of AsciiDoc
documents) and destination (where HTML documents are generated), namedly
+#:from+ and +#:to+ as in <<func/generate-src,+generate-src+>>.

.code::generate-html
[source,racket,linenums]
----
(define (generate-html #:from      [from "src"]
                       #:to        [to "generated-html"])
  (let* ([from  (get-path from)]
         [to    (get-path to)]
         [docs  (if (file-exists? from)
                    (let ([file (list from)])
                      (set! from (path->directory from))
                      file)
                    (list-all-adocs from))])
    (parameterize ([current-directory from])
      (for ([doc docs])
        (render-asciidoc doc
                         (get-relative-path to (get-output-file doc)))))))

----

Let's dig into some helpers for this function.  The first helper to notice is
+render-asciidoc+, used to build and run rendering command with AsciiDoctor.

By default, AsciiDoctor is invoked with +--doctype book+.  Customization could
be added later.

.code::render-asciidoc
[source,racket,linenums]
----
(define asciidoctor-format-command
  #λ(format "asciidoctor ~a -d book -o ~a" %1 %2))

(define (render-asciidoc input-file output-file)
  (displayln (str "-> " input-file " => " output-file))
  (system (asciidoctor-format-command input-file output-file)))

----

And last but not least, for +generate-html+ to be ready, we need a function to
extract file name and replace +.adoc+ extension with +.html+ extension.

.code::get-output-file
[source,racket,linenums]
----
(define get-output-file
  #λ(~> (file-name-from-path %)
      path->string
      (string-replace ".adoc" ".html")))

(module+ test
  (check-equal? (get-output-file "/tmp/tmp.adoc")   "tmp.html")
  (check-equal? (get-output-file "/tmp/world.adoc") "world.html"))

----

The code for command +generate-html+ is as simple as followed:

.file::commands/generate-html.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

(module+ test
  (require rackunit))

;; include::render-asciidoc

;; include::get-output-file

;; include::generate-html

(define (run #:from [from "src"]
             #:to   [to   "generated-html"])
  (display-command "Generating HTML")
  (generate-html #:from from
                 #:to   to))

----

== The +ulqui+ script

So far we have been going through all important internal components of
Ulquikit.  What's left to make a complete, usable application is the main
command that takes care of user interactive: the +ulqui+ script.  +ulqui+ is a
complete Racket module.

First and foremost, this module should be able to detect all built-in commands
residing in +commands/+ directory.  This task is simple and straightforward:
find all +.rkt+ files is +commands/+ directory and return them as a list
without their extensions.

.code::ulqui/list-commands
[source,racket,linenums]
----
(define (list-commands)
  (let* ([command-dir (get-path +ulqui-dir+ "../commands/")]
         [commands    (~>> (directory-list command-dir)
                        (map path->string)
                        (filter #λ(string-ends-with? % ".rkt"))
                        (map #λ(regexp-replace #px"\\.rkt$" % "")))])
    commands))

----

+ulqui+ might be liked, or copied indenpently, so the help of +ulqui+ should
should be within in source.  Besides, whenever help is called, +ulqui+ should
be able to detect all available commands and brief their helps.

.code::ulqui/display-help
[source,racket,linenums]
----
(define (display-help)
  (displayln
   @str{Usage: ulqui <command> [options] ...

Ulquikit is yet another literate programming tool, with the main tasks of
generating code and documentation from literate source.

Supported markup language: AsciiDoc.
Supported output formats for documentation: HTML.

Available commands:

})
  (let* ([commands   (list-commands)]
         
         [full-helps (map #λ(with-output-to-string
                              (λ ()
                                (run-help %))) commands)]
         
         [helps      (for/list ([text full-helps])
                       (let* ([lines (string-split text "\n" #:trim? #f)]
                              [usage-omitted (dropf lines
                                                    #λ(not (string=? % "")))]
                              [help (takef (rest usage-omitted)
                                           #λ(not (string=? % "")))])
                         (string-join help "\n")))])
    (map (λ (command help)
           (displayln (str (format (~a command
                                       #:width 15))
                           " :: "
                           help)))
         commands
         helps))
  (newline)
  (displayln
   @str{
Use 'ulqui help' or 'ulqui --help' to bring up this help.
Use 'ulqui help <command>' or 'ulqui <command> --help' to get help for a
command.
Use 'ulqui --version' to display current running version of Ulquikit.})
  (newline))

----

One important thing to note is that +ulqui+ script might be linked to and run
from different places.  Once it has been linked, Ulquikit directory is not the
directory that contains this script anymore, thus it needs to be re-calculated
and all functions which are imported need to be ++require++d manually:

.code::ulqui/require-utils
[source,racket,linenums]
----
(define +ulqui-script-path+
  (resolve-path (syntax-source #'here)))

(define +ulqui-dir+
  (let-values ([(base name must-be-dir?)
                (split-path +ulqui-script-path+)])
    base))

(define get-ulqui-module-path
  #λ(build-path +ulqui-dir+ %))

(define +ulquikit-version+
 (dynamic-require (get-ulqui-module-path "../ulquikit.rkt")
                  '+ulquikit-version+))

(define string-ends-with?
 (dynamic-require (get-ulqui-module-path "../utils/string.rkt")
                  'string-ends-with?))

(define get-path
  (dynamic-require (get-ulqui-module-path "../utils/path.rkt")
                   'get-path))

(define run-help
  (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                   'run-help))

(define run-command
 (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                  'run-command))
----


Putting all things mentioned above together, we have the following +ulqui+
script.  To make the script as practical as possible, certain things should be
clarified:

* By default, running +ulqui+ alone usually means users need some help.  Thus
  running +ulqui+ is equivalent to running +ulqui help+.

* If users execute invalid command, this script also fallbacks to +ulqui
  help+ with a small error message.

.file::bin/ulqui
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

;; include::ulqui/display-version

;; include::ulqui/require-utils

;; include::ulqui/list-commands

;; include::ulqui/display-help

(module+ main
  (void
   (let* ([command-list (list-commands)]
          [arguments (vector->list (current-command-line-arguments))]
          [arg-list  (if (empty? arguments)
                         '("help")
                         arguments)]
          [command   (first arg-list)]
          [args      (rest arg-list)])
     (cond [(string=? "help" command)
            (if (empty? args)
                (display-help)
                (run-help (first args)))]
           [(string=? "--version" command)
            (display-version)]
           [(not (member command command-list))
            (displayln (str "-> Invalid command " command ".\n"))
            (display-help)]
           [else
            (run-command command args)]))))

----

Oh, and let's not forget this small but useful function: +display-version+

.code::ulqui/display-version
[source,racket,linenums]
----
(define (display-version)
  (displayln (str "Ulquikit v" +ulquikit-version+)))
----


== Managing Ulquikit source code

As Ulquikit grows, the need for a script/tool to manage source code,
release, ... arises.  This +schiffer+ script (named after last name of
http://en.wikipedia.org/wiki/List_of_Hollows_in_Bleach#Ulquiorra_Schiffer[Ulquiorra
Schiffer]) is born to fulfilled that need.

=== Generate source code and HTML documents, all at once

This function simply makes a call to <<command/generate-src,+generate-src+>>
and <<command/generate-html,generate-html>> commands.  Note that the
+schiffer+ script only has its use inside Ulquikit project, so when it's
generated, it's moved outside +generated-src+.  Also, all files in
+generated-src/bin/+ directory should be given executable permission.

.code::schiffer/generate-all
[source,racket,linenums]
----
(define (generate-src)
  (system "ulqui generate-src")

  (displayln "=> Giving executable permission to generated-src/bin/*")
  (system "chmod +x generated-src/bin/*")
  (newline)

  (displayln "=> Moving schiffer to current directory")
  (rename-file-or-directory "generated-src/bin/schiffer"
                            "schiffer-dev"
                            #t)
  (displayln "   generated-src/bin/schiffer => ./schiffer-dev")
  (newline)

  (displayln "=> Moving quick installation script to current directory")
  (rename-file-or-directory "generated-src/bin/quick-install.sh"
                            "quick-install.sh"
                            #t)
  (displayln "   generated-src/bin/quick-install.sh => ./quick-install.sh")
  (newline))

(define (generate-html)
  (system "ulqui generate-html")
  (newline))

(define (generate-all)
  (generate-src)
  (generate-html))

----

=== Update-self

This function simply copy and replace +schiffer+ script with +schiffer-dev+
without re-generating source code.

.code::schiffer/update-self
[source,racket,linenums]
----
(define (update-self)
  (displayln "=> Replacing schiffer with schiffer-dev")
  (copy-file "schiffer-dev" "schiffer" #t)
  (displayln "   ./schiffer-dev -> ./schiffer")
  (newline))

----

=== Mark current source as stable

Marking current generated source code as stable by replacing
+release/ulquikit+ with +generated-src+.  Note that this function/command does
*not* re-generate source code.

.code::schiffer/mark-stable
[source,racket,linenums]
----
(define (mark-stable)
  (displayln "=> Removing current stable")
  (delete-directory/files "release" #:must-exist? #f)
  (newline)

  (displayln "=> Creating stable directory: release")
  (make-directory* "release")
  (newline)

  (displayln "=> Copying current generated source to stable")
  (displayln "   generated-src -> release/ulquikit")
  (copy-directory/files "generated-src" "release/ulquikit")
  (newline)

  (displayln "=> Copying docs")
  (displayln "   generated-html -> release/ulquikit/docs")
  (copy-directory/files "generated-html" "release/ulquikit/docs")
  (newline))

----

=== Release

[[schiffer/mark-release]]
.code::schiffer/mark-release
[source,racket,linenums]
----
(define (mark-release)
  (mark-stable)
  (let* ([latest-tag       (~> (process "git tag")
                             first
                             port->string
                             string-split
                             last)]
         [filename         (format "ulquikit-~a.zip" latest-tag)]
         [zip-command      (format "zip -r ~a ulquikit" filename)]
         [checksum-command (format "md5sum ~a > ~a.md5"
                                   filename
                                   filename)])
    (parameterize [(current-directory "release")]
      (displayln (str "=> Creating release/" filename))
      (system zip-command)
      (newline)

      (displayln (str "=> Creating checksum for release/" filename))
      (system checksum-command)
      (displayln (str "   release/" filename " => release/" filename ".md5"))
      (newline))))

----


=== Run current dev version of Ulquikit

Running current Ulquikit dev version is done by calling
+generated-src/bin/ulqui+.

.code::schiffer/ulqui-dev
[source,racket,linenums]
----
(define (ulqui-dev args)
  (system (str "generated-src/bin/ulqui "
               (~> (map #λ(string-append "'" % "'") args)
                 (string-join " "))))
  (newline))

----

=== Run tests

By calling +raco test generated-src/*+.

.code::schiffer/run-tests
[source,racket,linenums]
----
(define (run-tests)
  (system "raco test generated-src/*")
  (newline))

----

=== Clean up

Simply removing +generated-html+ and +generated-src+ directories:

.code::schiffer/clean-up
[source,racket,linenums]
----
(define (clean-up)
  (displayln "=> Removing generated-html")
  (delete-directory/files "generated-html" #:must-exist? #f)
  (displayln "=> Removing generated-src")
  (delete-directory/files "generated-src" #:must-exist? #f)
  (newline))
----

=== Help

Of course, help is particularly useful.

.code::schiffer/help
[source,racket,linenums]
----
(define (help)
  (displayln @str{
Usage: schiffer <command> [options] ...

Schiffer is a simple build script for Ulquikit.

Available commands:

  generate-src  :: Generate Ulquikit source code to 'generated-src'.
  generate-html :: Generate Ulquikit HTML docs to 'generated-html'.
  generate-all  :: Call 'generate-src', then 'generate-html'.
  update-self   :: Update Schiffer, replace itself with './schiffer-dev'.
  mark-stable   :: Mark current 'generated-src' as stable by copying it into
                   'release/ulquikit'
  mark-release  :: Mark current stable in 'release/ulquikit' as release by
                   zipping it with latest Git tag name.  E.g.
                  'release/ulquikit' is zipped into 'release/ulquikit-v2.0.zip'.
  ulqui-dev     :: Analogous to 'generated-src/bin/ulqui'.
  clean-up      :: Clean up generated source and HTML.
  run-tests     :: Run all Ulquikit tests in 'generated-src/'.
  help          :: Print this help.

Note that only 'ulqui-dev' takes options.
})
  (newline))

----


=== Combine into +schiffer+

.file::bin/schiffer
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

(require net/url)

;; include::schiffer/generate-all

;; include::schiffer/update-self

;; include::schiffer/mark-stable

;; include::schiffer/mark-release

;; include::schiffer/ulqui-dev

;; include::schiffer/clean-up

;; include::schiffer/run-tests

;; include::schiffer/help

(module+ main
  (void
   (let* ([args    (current-command-line-arguments)]
          [command (vector-ref (if (zero? (vector-length args))
                                   #("")
                                   args)
                               0)])
     (match command
       ["generate-src"     (generate-src)]
       ["generate-html"    (generate-html)]
       ["clean"            (clean-up)]
       ["update-self"      (update-self)]
       ["mark-stable"      (mark-stable)]
       ["mark-release"     (mark-release)]
       [(or "ulqui-dev"
            "run-dev")     (ulqui-dev (vector->list (vector-drop args 1)))]
       [(or "test"
            "run-tests")   (run-tests)]
       [(or "generate-all"
            "build")       (generate-all)]
       [_                  (help)]))))
----

== Updating Ulquikit

As more versions of Ulquikit are released, having a way to update Ulquikit
from the command line is very helpful.  One way to do this is by adding
+update+ command, so that users could update Ulquikit to latest version just
by running:

[source,sh]
----
ulqui update
----

=== Retrieve latest version

Ulquikit is officially released via
https://help.github.com/articles/about-releases[Github Releases], which
provides this URL https://github.com/cmpitg/ulquikit/releases/latest pointing
to latest release.

First of all, let's +curl+ this URL to see how it's redirected:

[source,sh,linenums]
----
curl --head https://github.com/cmpitg/ulquikit/releases/latest

# HTTP/1.1 302 Found
# Server: GitHub.com
[snip]
# Location: https://github.com/cmpitg/ulquikit/releases/tag/v0.2
[snip]
----

So that's how it works, simple and straightforward.  The job now is to get the
"Location" attribute from HTTP header and grab the version.  With Racket's
http://docs.racket-lang.org/net/url.html[+net/url+] library, it becomes trivial:

.code::ulqui/latest-version
[source,racket,linenums]
----
(define +latest-release-url+
  (string->url "https://github.com/cmpitg/ulquikit/releases/latest"))

(define (get-latest-version)
  (~> (call/input-url +latest-release-url+
                      head-impure-port
                      port->string)
    string-split
    (dropf #λ(not (string=? "Location:" %)))
    second
    (#λ(regexp-match #rx"v(.*)" %))
    second))

----

Note that we use
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-impure-port%29%29[+head-impure-port+]
instead of
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-pure-port%29%29[+head-pure-port+]
as the response might content body.

=== Download and replace Ulquikit

==== Construct download URL

Let's have a closer look: Version 2.0 has
https://github.com/cmpitg/ulquikit/releases/download/v0.2/ulquikit-v0.2.zip as
its download URL.  The filename +ulquikit-v0.2.zip+ certainly depends on
naming convention, which <<schiffer/mark-release,+schiffer+>> has got us
covered.  So all download URLs follow the following format:
+https://github.com/cmpitg/ulquikit/releases/download/v{latest-version}/ulquikit-v{latest-version}.zip+.
Based on that, we have this function to construct download URL of the latest
version:

.code::ulqui/construct-download-url
[source,racket,linenums]
----
(define (construct-download-url [version (get-latest-version)])
  (format "https://github.com/cmpitg/ulquikit/releases/download/v~a/ulquikit-v~a.zip"
          version
          version))
----

==== Download and unzip

There are a couple of ways to download and unzip the release file, among which
the following 2 are the most commonly used:

* Using Racket's own API - bad in performance and memory space.

* Calling shell commands - platform-dependant but much better in performance.

Let's make this work first then improve later.  I'm going to choose the 2^nd^
option for now.

Note that +system+ is used to call external commands, which in turn produce
some data to standard output and standard error.  Thus we make standard output
and standard error unbeffered during to +system+ call to achieve the best
result.

.code::ulqui/download-and-unzip
[source,racket,linenums]
----
(define (download-and-unzip version to-dir)
  (parameterize ([current-directory to-dir])
    (let ([url              (construct-download-url version)]
          [filename         (format "ulquikit-v~a.zip" version)]
          [out-buffer-mode  (file-stream-buffer-mode (current-output-port))]
          [err-buffer-mode  (file-stream-buffer-mode (current-error-port))])

      (with-handlers ([exn:fail?
                       (λ (_)
                         (file-stream-buffer-mode (current-output-port)
                                                  out-buffer-mode)
                         (file-stream-buffer-mode (current-error-port)
                                                  err-buffer-mode))])
        (file-stream-buffer-mode (current-output-port) 'none)
        (file-stream-buffer-mode (current-error-port) 'none)

        (displayln (str "-> Downloading from " url))
        (system (str "curl -O " url))

        (displayln (str "-> Unzipping " filename ", replacing old version with new version"))
        (system (str "unzip -o " filename))

        (displayln (str "-> Removing " filename))
        (delete-directory/files filename)

        (file-stream-buffer-mode (current-output-port) out-buffer-mode)
        (file-stream-buffer-mode (current-error-port) err-buffer-mode)))))

----

=== The +update+ command

.file::commands/update.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require net/url)

(require "../ulquikit.rkt")
(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

;; include::ulqui/latest-version

;; include::ulqui/construct-download-url

;; include::ulqui/download-and-unzip

(define (run)
  (display-command "Updating Ulquikit")
  (displayln (str "-> Current version: " +ulquikit-version+))
  (let ([latest-version (get-latest-version)])
    (displayln (str "   Latest version:  " latest-version))
    (cond [(string=? latest-version +ulquikit-version+)
           (newline)
           (displayln (str "   Congratulations! You are running the latest version of Ulquikit!"))]
          [else
           (download-and-unzip latest-version +ulquikit-location+)])))

----

Of course, a little piece of help text is always necessary.

.file::commands/update.help.txt
[source,text,linenums]
----
Usage: update

Update Ulquikit to latest version.

----

== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

=== Quick installation script

This comes in handy at times.  The script assumes that *users have already
installed Racket and Ruby*.

The user-friendliness provided by the script is the most important, so let's
decide upon how it looks like:

.file::bin/quick-install.sh
[source,sh,linenums]
----
#!/bin/sh

## include::quick-install/racket

## include::quick-install/ruby

## include::quick-install/asciidoctor

## include::quick-install/rackjure

## include::quick-install/ulquikit

----

Bourne shell is a horrible language, so even a simple check-and-make-decision
might end up look like:

[source,sh,linenums]
----
if [ `which some-exec >/dev/null 2>&1 && echo true || echo false` == "true" ]; then
   # Do-something
fi
----

Unfortunately, each part of this +quick-install.sh+ script requires that kind
of check.  Let's walk through them one by one.

==== Make sure Racket is installed

This task is simple done by checking whether +racket+ executable is found.
Note that it doesn't check Racket version.  The script fails if Racket is not
installed, thus the +exit 1+ command.

.code::quick-install/racket
[source,sh,linenums]
----
if [ `which racket >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Racket not found, please install it first."
    echo "   You might refer to your OS's package manager to install Racket,"
    echo "   or download it from: http://racket-lang.org/download/"
    echo "   Please MAKE SURE you have Racket 6+."
    echo "-> Installation aborted."
    exit 1
else
    echo "-> Found Racket.  MAKE SURE you have Racket 6+."
fi

----

==== Install Ruby 1.9 (using RVM) if necessary

.code::quick-install/ruby
[source,sh,linenums]
----
if [ `which ruby >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Ruby not found."
    echo "   You might refer to your OS's package manager to install Ruby."
    echo "   However, this script could install Ruby for you using RVM stable."
    echo "   Please refer to http://rvm.io for further information."

    echo -n "-> Would you like to install RVM stable single-user mode? [Y/n] "
    read DO_INSTALL_RVM

    if [ "$DO_INSTALL_RVM" == "" ] \
        || [ "$DO_INSTALL_RVM" == "y" ] \
        || [ "$DO_INSTALL_RVM" == "Y" ]; then
        echo "-> Installing Ruby 1.9 and RVM..."

        \curl -sSL https://get.rvm.io | bash -s stable
        [[ -f ~/.bashrc ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.bashrc)
        [[ -f ~/.zshrc  ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.zshrc)
        source $HOME/.rvm/scripts/rvm
        rvm install 1.9
        rvm use 1.9 --default
    else
        echo "-> Installation aborted."
        exit 1
    fi
else
    echo "-> Found Ruby.  MAKE SURE you have Ruby 1.9+."
fi
----

==== Install AsciiDoctor if necessary

.code::quick-install/asciidoctor
[source,sh,linenums]
----
if [ `which asciidoctor >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> AsciiDoctor found."
else
    echo "-> Installing AsciiDoctor..."
    gem install -V asciidoctor
fi

----

==== Install Rackjure if necessary

.code::quick-install/rackjure
[source,sh,linenums]
----
if [ `(raco pkg show | grep rackjure) >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> Rackjure found."
else
    echo "-> Installing Rackjure..."
    raco pkg install rackjure
fi

----

==== Install Ulquikit

NOTE: +DOWNLOAD_URL+ needs to change everytime there's new release.

.code::quick-install/ulquikit
[source,sh,linenums]
----
DOWNLOAD_URL=https://github.com/cmpitg/ulquikit/releases/download/v0.2.1/ulquikit-v0.2.1.zip

echo -n "-> Where would you like to install/update Ulquikit? (default: $HOME/) "
read ULQUIKIT_DEST
eval ULQUIKIT_DEST=$ULQUIKIT_DEST

if [ "$ULQUIKIT_DEST" == "" ]; then
    ULQUIKIT_DEST=$HOME/
fi

cd $ULQUIKIT_DEST

echo "-> Downloading latest version..."
wget -q "$DOWNLOAD_URL" -O ulquikit.zip

echo "-> Unpacking..."
unzip ulquikit.zip

echo "-> Removing zip file..."
rm -f ulquikit.zip

if [ `which ulqui >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo '-> Adding ulquikit/bin to your $PATH'
    [[ -f ~/.bashrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.bashrc)
    [[ -f ~/.zshrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.zshrc)

    echo "-> Done!  Enjoy your time with literate programming!"
else
    echo '-> Found ulqui command in your $PATH.'
fi

export PATH=$ULQUI_DEST/ulquikit/bin:$PATH

----

== Other meta-information

I figure out it's a good practice to good the application's meta-information
into one module.  Currently, it only contain version information and a way to
retrieve location of Ulquikit.

.file::ulquikit.rkt
[source,racket,linenums]
----
;; include::license-header

#lang racket

(require racket/path)

(provide +ulquikit-version+
         +ulquikit-location+)

;; include::ulquikit-version

;; include::ulquikit-location

----

Retrieving location of Ulquikit is simple and straightforward, we'll use
+syntax-source+ to do that:

.code::ulquikit-location
[source,racket,linenums]
----
(define-values (+ulquikit-location+ _ __)
  (split-path (syntax-source #'here)))

----

== License header

Since Ulquikit is distributed under the terms of GPLv3, the license header is
necessary.

.code::license-header
[source,racket]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014 Nguyễn Hà Dương <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----

== Extras

== Utility functions

See link:Utilities.html[Utilities].

=== Command list

=== Story: How the Racket version of Ulquikit was actually developed
