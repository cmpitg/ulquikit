= Ulquikit
:Author: Ha-Duong Nguyen (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Current version:

.code::declare-version
[source,lisp,linenums]
----
(defvar *ulquikit-version* "2.0.0")
----

'''

Ulquikit is an extensible literate programming tool supporting multiple markup
languages with user-friendly interface.

Ulquikit was originally written in Racket.  The current version is a complete
rewrite in Common Lisp for better startup time and deployment.

This document is the literate source code Ulquikit itself.  TODO: Reason why
Ulquikit exists.

To build Ulquikit, the following dependencies are required:

* Ruby 2.1+ with
** http://asciidoctor.org[AsciiDoctor] - AsciiDoc renderer
** https://github.com/tmm1/pygments.rb[pygments.rb] - syntax highlighter
* An ANSI-compliant Common Lisp implementation, preferably
  http://www.sbcl.org[SBCL], with
** https://common-lisp.net/project/asdf[ASDF 3] - build tool
** https://www.quicklisp.org/beta/[Quicklisp] - library manager
** https://github.com/fukamachi/shelly[Shelly] - shelly-friendly interface

To install them, please consult their official documentations.  On my setup, I
use:

* SBCL 1.2+ with https://github.com/KeenS/CIM[CIM] (Common Lisp Implementation
  Manager)
* Ruby 2.1.3 with https://rvm.io[RVM] (Ruby Version Manager)

TODO: quick installation

== Terminology

* A *code block* is an AsciiDoc/Markdown/whatever-markup-language's code
  block.

* A *snippet* is a code block with Ulquikit-defined title.  By default, a code
  block title that starts with `file::` and `code::` defines a _file snippet_
  and _code snippet_, respectively:

** A *file snippet* is a snippet that could be generated to a file.
** A *code snippet* is a snippet storing a piece of text (or source code) that
   can be included into other snippets.

* An *include directive* is a line of code that:

** belongs to a snippet
** has the format of `xx include::some-snippet-name` where `xx` are two
   identical characters denoting a comment.  Ulquikit can also recogize the
   following comment types: `//`, `;;`, `##`, `--`, C-stype `/*
   include::some-snippet-name */`, or XML-style `<!--
   include::some-snippet-name -->`.

== Interfaces

Before going into any detail, let us define the interface that Ulquikit uses
to interact with the outside world.

Ulquikit is essentially a collection of Common Lisp packages.  The main
package is called `ulquikit` itself, along with its test counterpart
`ulquikit-tests`.

I decide to use https://github.com/OdonataResearchLLC/lisp-unit[lisp-unit]
since it has very nice interface and helpful messages.

NOTE: Prior to `lisp-unit`, I have tried
https://github.com/capitaomorte/fiasco[Fiasco] with little success.  The API
is nice but inflexible.  There is no easy way to remove or redefine tests/test
packages.

.file::ulquikit.lisp
[source,lisp,linenums]
----
(defpackage #:ulquikit
  (:use :cl
        :alexandria
        :split-sequence
        :cl-ppcre
        :cl-cwd
        :trivial-utf-8
        :iterate
        :ulqui/utils)
  (:export #:generate-src
           #:generate-html

           #:snippet->string
           #:sethash
           #:file?

           #:snippet
           #:create-snippet
           #:extract-snippets
           #:extract-snippets-from-file
           #:collect-snippet
           #:get-all-adocs))

(defpackage #:ulquikit-tests
  (:use :cl :ulquikit :cl-ppcre :lisp-unit :iterate :cl-fad))

(in-package #:ulquikit-tests)

;; Print failure details by default
(setf *print-failures* t)

----

== Extracting and including snippets

Ulquikit works by

. searching for all AsciiDoc documents inside `<project-root>/src` directory,
. building a database of snippets,
. including them into each other if necessary, then,
. generating documentation and source code.

Hence, the following functions are the most important:

* <<func/extract-snippets-from-file,`extract-snippets-from-file`>>, that
  extracts snippets from a file

* <<func/include-snippet,`include-snippet!`>>, that serves as a building block
  to <<section/include-snippets,include snippets>> into each other

=== Extracting snippets

First, we need to decide how snippets are stored.  This is very important as
every change made to this data structure would affect the code later on.

Each snippet is a struct with the following alist representation:

anchor:snippet-format[]

[source,lisp]
----
((:type       . ,snippet-type)  <1>
 (:name       . ,snippet-name)  <2>
 (:linenum    . ,line-number)   <3>
 (:lines      . ,snippet-lines) <4>
 (:processed? . ,processed?))   <5>
----
<1> is either `:file` or `:code`
<2> is the name of the snippet; e.g. snippet with title `file::something` has
`something` as its name.  Snippet name is _a string_.
<3> is the line number from the literate source code from where the snippet is
extracted
<4> is the content of the snippet as a list of lines
<5> determines whether this snippet has been processed?, when created for the
first time, `:processed?` is always `nil`.  It is only changed after the
snippet has been passed through <<func/include-snippet,+include-snippet!+>>

Thus, the struct representation of a snippet is as followed:

.code::define-snippet-struct
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defstruct (snippet (:conc-name snippet/))
  (type :code     :type keyword)
  (name ""        :type string)
  (linenum 0      :type integer)
  (lines (list)   :type list)
  (processed? nil :type boolean))

----

IMPORTANT: Snippets should never be created directly with `make-snippet`.
Instead, they should be created with <<create-snippet,`create-snippet`>>.

Since a snippet stores a list of lines as its content, it'd be convenient to
have a helper that joins those lines into a complete string:

.code::get-snippet-content
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun get-snippet-content (snippet)
  "Returns the content of a snippet as string."
  (declare (snippet snippet))
  (join-lines (snippet/lines snippet)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun join-lines (lines)
  "Joins a list of strings with newline as separator."
  (declare (list lines))
  (the string (format nil "~{~A~^~%~}" lines)))

(in-package #:ulquikit-tests)

(define-test test-join-lines
  (assert-equal "" (ulquikit::join-lines '()))
  (assert-equal "a" (ulquikit::join-lines '("a")))
  (assert-equal (format nil "a~%b") (ulquikit::join-lines '("a" "b")))
  (assert-equal (format nil "a~%b~%") (ulquikit::join-lines '("a" "b" ""))))

;; (run-tests '(test-join-lines))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

`create-snippet` is simply implemented as followed:

anchor:func/create-snippet[]
.code::create-snippet
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun create-snippet (&key
                         (type :code)
                         (name "")
                         (linenum 1)
                         (lines (list))
                         (processed? nil))
  "Helper to create snippet."
  (declare ((or string symbol) type name)
           ((or string list) lines)
           (integer linenum)
           (boolean processed?))
  (let ((type (->keyword type))
        (name (->string name))
        (lines (if (stringp lines)
                   (split-sequence #\Newline lines)
                 lines)))
    (the snippet (make-snippet :type type
                               :name name
                               :linenum linenum
                               :lines lines
                               :processed? processed?))))

(in-package #:ulquikit-tests)

(define-test test-snippet-creation
  (assert-equalp (make-snippet :type :file
                               :name "hello-world"
                               :linenum 10
                               :lines ("Hmm")
                               :processed? nil)
                 (ulquikit::create-snippet :type :file
                                           :name 'hello-world
                                           :linenum 10
                                           :lines '("Hmm")))
  (assert-equalp (make-snippet :type :string
                               :name "string"
                               :linenum 100
                               :lines ("string")
                               :processed? t)
                 (ulquikit::create-snippet :type "string"
                                           :name "string"
                                           :linenum 100
                                           :lines "string"
                                           :processed? t)))

;; (run-tests)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun ->keyword (val)
  "Converts a symbol or string into keyword."
  (declare ((or symbol string) val))
  (the keyword (etypecase val
                 (keyword val)
                 (symbol (intern (string-upcase (symbol-name val)) 'keyword))
                 (string (intern (string-upcase val) 'keyword)))))

(defun ->string (val)
  "Converts a symbol or keyword into string."
  (declare ((or symbol string) val))
  (the string (etypecase val
                (string val)
                ((or symbol keyword) (string-downcase (symbol-name val))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

Now all snippet creation utilities are ready.  Let's move on to
`extract-snippets-from-file`.

`extract-snippets-from-file` needs to determine whether _a line in a code
block_ belongs to a _code snippet_, or _file snippet_, or none of those, then
extracts content of the code block and store it if necessary.  The 3 types
of code block that we deal with are as followed:

* A _code snippet_ has the following format:
+
[listing]
..........
.code::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.code::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........


* A _file snippet_ shares the same structure as a _code snippet_:
+
[listing]
..........
.file::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.file::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........

* A non-snippet code block is any block without +code::...+ or +file::...+ as
  its title:
+
[listing]
..........
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>

....                            <3>
This is a literal block
....                            <4>
..........

<1> block title
<2> block type
<3> block delimiter
<4> block delimiter

As we can clearly see from the 3 examples, _code snippets_ and _file snippets_
could be determined by checking 2^nd^ previous line from block delimiter to
see if it starts with `.file::` or `.code::`.  Everything between the 2
delimiters is stored as content of the snippet.

Before diving into `extract-snippets-from-file`, let us define a data
structure for storing all snippets:

.code::define-snippets-struct
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defstruct (snippets
             (:conc-name snippets/))
  (file (make-hash-table :test #'equal) :type hash-table)
  (code (make-hash-table :test #'equal) :type hash-table))
----

We have the following algorithm for `extract-snippets-from-file`:

* Read the content of the file;

* Break the content into lines, preserving line numbers;

* For each line:

** If we're already inside a snippet:

*** Complete a snippet and add it to snippet list if current line is a block
    delimiter (i.e. `----`)

*** Add current line to the current snippet's content if current line is not a
    block delimiter

** If we're outside a snippet, we only care if current line is a block
   delimiter (i.e. `----`):

*** If this block has a title that marks the beginning of a snippet (i.e. the
    2^nd^ previous line starts with `.file::` or `.code::`), extract snippet
    name and add a new snippet.  Otherwise

*** If this block does not mark the beginning of a snippet, ignore it.

anchor:func/extract-snippets-from-file[]
.code::extract-snippets-from-file
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun extract-snippets-from-file (path)
  "Extracts snippets from a file and return a `snippets' struct."
  (declare ((or string pathname) path))
  (let* ((text (string-trim '(#\Space #\Newline #\e #\t #\m) (read-file path)))
         (lines (split-sequence #\Newline text))

         (snippets (make-snippets))

         (prev-prev-line "")
         (prev-line      "")
         (linenum        0)             ; current line number
         (inside?        nil)           ; currently inside a snippet?

         (s/type       :code)
         (s/lines/rev  (list))
         (s/name       "")
         (s/linenum    0))
    (dolist (line lines)
      (incf linenum)

      ;; (format t "~A |> ~A~%" linenum line)
      ;; (format t "   |> block? ~A~%" (block-delimiter? line))

      (cond ((and inside? (not (block-delimiter? line)))

             (push line s/lines/rev))

            ((and inside? (block-delimiter? line))

             ;; Close the current snippet
             (setf inside?  nil
                   snippets (collect-snippet snippets
                                             (create-snippet
                                              :type s/type
                                              :name s/name
                                              :lines (nreverse s/lines/rev)
                                              :linenum s/linenum))))

            ((and (not inside?) (block-delimiter? line))
             ;; (format t "  found snippet > num: ~A~%" linenum)

             (when-let (title (cond ((block-title? prev-line) prev-line)
                                    ((block-title? prev-prev-line) prev-prev-line)
                                    (t nil)))
               (multiple-value-bind (type name) (parse-snippet-title title)
                 (setf inside?     t
                       s/type      type
                       s/name      name
                       s/lines/rev (list)
                       s/linenum   (1- linenum))))))

      ;; Update previous lines
      (unless (zerop (length (string-trim '(#\Space #\Newline #\e #\t #\m) line)))
        (setf prev-prev-line prev-line
              prev-line      line)))

    ;; (list linenum (length lines) snippets)
    snippets))

;; (extract-snippets-from-file "/m/src/ulquikit/src/Ulquikit.adoc")
;; (time (extract-snippets-from-file "/m/src/ulquikit/src/Ulquikit.adoc"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun sethash (key hash value &rest args)
  "Conveniently combining `setf' and `gethash'.

`\(setf \(gethash o hash\) obj\)' ⬄ `\(sethash o hash obj\)'
`\(setf \(gethash o hash\) obj
      \(gethash a hash\) abj\)'
⬄
`\(sethash o hash obj
         a hash abj\)'
"
  (declare (hash-table hash))
  (unless (zerop (mod (length args) 3))
    (error "number of arguments must be divisible by 3."))

  (setf (gethash key hash) value)

  (unless (null args)
    (apply #'sethash (first args) (second args) (third args) (subseq args 3))))

(in-package #:ulquikit)

(defun read-file (path)
  "Reads a file as UTF-8 encoded string."
  (declare ((or string pathname) path))
  (with-open-file (in path :element-type '(unsigned-byte 8))
    (read-utf-8-string in :stop-at-eof t)))

(in-package #:ulquikit)

(defun block-delimiter? (str)
  "Determines if a string is a block delimiter.  TODO: Make this extensible."
  (declare (string str))
  (scan "^----( *)$" str))

(in-package #:ulquikit-tests)

(define-test test-block-delimiter
  (assert-true (ulquikit::block-delimiter? "----"))
  (assert-true (not (ulquikit::block-delimiter? " ----")))
  (assert-true (ulquikit::block-delimiter? "---- "))
  (assert-true (ulquikit::block-delimiter? "----  "))
  (assert-true (not (ulquikit::block-delimiter? "----a"))))

;; (run-tests '(test-block-delimiter))

(in-package #:ulquikit)

(defun block-title? (str)
  "Determines if a string is a block title.  TODO: Make this extensible."
  (declare (string str))
  (scan "^\\.(file|code)::" str))

(in-package #:ulquikit-tests)

(define-test test-block-title
  (assert-true (ulquikit::block-title? ".file::something"))
  (assert-true (ulquikit::block-title? ".file::something else"))
  (assert-true (ulquikit::block-title? ".file::"))
  (assert-true (null (ulquikit::block-title? ".file:something"))))

;; (run-tests '(test-block-title))

(in-package #:ulquikit)

(defun parse-snippet-title (title)
  "Parses a snippet title and returns `(values <snippet-type>
<snippet-name>)'."
  (declare (string title))
  (multiple-value-bind (_ res) (scan-to-strings "\.(file|code)::(.*)" title)
    (declare (ignore _))
    (values (the keyword (->keyword (aref res 0)))
            (the string  (aref res 1)))))

(in-package #:ulquikit-tests)

(define-test test-parse-snippet-title
  (dolist (el '((".file::"    . (:file ""))
                (".code::"    . (:code ""))
                (".file::abc" . (:file "abc"))
                (".code::a b" . (:code "a b"))))
    (let ((title    (first el))
          (expected (rest  el)))
      (multiple-value-bind (type name) (ulquikit::parse-snippet-title title)
        (assert-equal expected (list type name))))))

;; (run-tests '(test-parse-snippet-title))

(in-package #:ulquikit)

(defun collect-snippet (snippets snippet)
  "Collects `snippet' into the list of snippets."
  (declare (snippets snippets)
           (snippet  snippet))
  (let* ((type (snippet/type snippet))
         (name (snippet/name snippet))
         (current-file (snippets/file snippets))
         (current-code (snippets/code snippets))
         (file (case type
                 (:file     (sethash name current-file snippet)
                            current-file)
                 (otherwise current-file)))
         (code (case type
                 (:code     (sethash name current-code snippet)
                            current-code)
                 (otherwise current-code))))
    (the snippets (make-snippets :file file
                                 :code code))))

(in-package #:ulquikit-tests)

(define-test test-collect-snippets
  (assert-equalp (collect-snippet (ulquikit::make-snippets)
                                  (create-snippet :type :file
                                                  :name :hello
                                                  :linenum 10
                                                  :lines '("Something")))
                 (ulquikit::make-snippets
                  :file (alexandria:alist-hash-table `(("hello" . ,(ulquikit::make-snippet
                                                                    :type :file
                                                                    :name "hello"
                                                                    :linenum 10
                                                                    :lines ("Something")
                                                                    :processed? nil)))
                                                     :test #'equal)
                  :code (make-hash-table :test #'equal)))

  (assert-equalp (collect-snippet
                  (ulquikit::make-snippets
                   :file (alexandria:alist-hash-table `(("hello" . ,(ulquikit::make-snippet
                                                                     :type :file
                                                                     :name "hello"
                                                                     :linenum 10
                                                                     :lines ("Something")
                                                                     :processed? nil)))
                                                      :test #'equal)
                   :code (make-hash-table :test #'equal))
                  (create-snippet :type 'code
                                  :name 'say-something
                                  :linenum 100
                                  :lines '("Something else")))
                 (ulquikit::make-snippets :file (alexandria:alist-hash-table
                                                 `(("hello" . ,(ulquikit::make-snippet
                                                                :type :file
                                                                :name "hello"
                                                                :linenum 10
                                                                :lines ("Something")
                                                                :processed? nil)))
                                                 :test #'equal)
                                          :code (alexandria:alist-hash-table
                                                 `(("say-something" . (ulquikit::make-snippet
                                                                       :type :code
                                                                       :name "say-something"
                                                                       :linenum 100
                                                                       :lines ("Something else")
                                                                       :processed? nil)))
                                                 :test #'equal))))

;; (run-tests '(test-collect-snippets))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

As a result, `extract-snippets`, which extracts snippets from all AsciiDoc
documents in a directory recursively, makes use of
`extract-snippets-from-file`.  `extract-snippets` takes a path and returns a
`snippets` struct.

.code::extract-snippets
[source,lisp,linenums]
----
;; include::extract-snippets-from-file

(in-package #:ulquikit)

(defun extract-snippets (path)
  "Extracts all snippets from all AsciiDoc directory in `path'.  The AsciiDoc
files are found recursively."
  (declare ((or string pathname) path))
  (labels ((merge-snippets (current-snippets adoc-file)
             (declare (snippets current-snippets)
                      ((or string pathname) adoc-file))
             (let ((new-snippets (extract-snippets-from-file adoc-file)))
               ;; Merging 2 snippets
               (maphash #'(lambda (key value)
                            (sethash key
                                     (snippets/file current-snippets)
                                     value))
                        (snippets/file new-snippets))
               (maphash #'(lambda (key value)
                            (sethash key
                                     (snippets/code current-snippets)
                                     value))
                        (snippets/code new-snippets))
               (the snippets current-snippets))))
    (reduce #'merge-snippets
            (get-all-adocs path)
            :initial-value (make-snippets))))

(in-package #:ulquikit-tests)

(define-test test-extract-snippets
  (let* ((test-dir (merge-pathnames
                    "ulquikit/test-extract-snippets/"
                    (cl-fad:pathname-as-directory (uiop:getenv "TMPDIR"))))

         (content `(("Main.adoc" . "= A sample program

This program consists of several snippets and a hello

== Main program

The main program includes function `say-hello` from `lib/Say-Hello.adoc` and
function `say-world` from `lib/Say-World.adoc` and calls them.

.file::/tmp/main.lisp
\----
;; include::say-hello

;; include::say-world

\(say-hello\)
\(say-world\)

\----
")
                    ("License" . "Do what you want to do with it!")
                    ("lib/Say-Hello.adoc" . "What do you actually expect in this
file?  Two snippets, one of which doesn't get captured.

.code::say-hello
[source,lisp,linenums]
\----
\(defun say-hello \(\)
  \(format t \"Hello \"\)\)
\----

The following snippet doesn't get captured as it has no title:

[source,lisp,linenums]
\----
\(defun throw-away \(\)
  \(error \"If you see me, there is at least one error happened!\"\)\)
\----
")
                    ("lib/Say-World.adoc" . "Another way to define code block title with AsciiDoc:

[source,lisp,linenums]
.code::say-world
\----
\(defun say-world \(\)
  \(format t \"world!~%\"\)\)
\----
")))
         (files (mapcar #'(lambda (content-pair)
                            (cons (merge-pathnames (car content-pair) test-dir)
                                  (cdr content-pair)))
                        content)))
    ;; Some how cl-fad doesn't work
    ;; (cl-fad:delete-directory-and-files test-dir :if-does-not-exist :ignore)
    (uiop:run-program (format nil "rm -rf ~A" test-dir) :shell t)
    (format t "Test dir: ~A~%" test-dir)

    (dolist (path+content files)
      (let ((path    (car path+content))
            (content (cdr path+content)))
        (ensure-directories-exist path)
        (with-open-file (out path :direction :output)
          (princ content out))))

    (let* ((snippets (ulquikit::extract-snippets test-dir))
           (file-snippets (ulquikit::snippets/file snippets))
           (code-snippets (ulquikit::snippets/code snippets)))
      (assert-equal 1 (hash-table-count file-snippets))
      (assert-equal 2 (hash-table-count code-snippets))

      (assert-equal ";; include::say-hello

;; include::say-world

\(say-hello\)
\(say-world\)
"
                    (snippet->string (gethash "/tmp/main.lisp" file-snippets)))
      (assert-equal "\(defun say-hello \(\)
  \(format t \"Hello \"\)\)"
                    (snippet->string (gethash "say-hello" code-snippets)))
      (assert-equal "\(defun say-world \(\)
  \(format t \"world!~%\"\)\)"
                    (snippet->string (gethash "say-world" code-snippets))))))

;; (run-tests '(test-extract-snippets))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (in-package #:ulquikit)

;; (defmacro sethash (obj hash value)
;;   "Helper macro, used to directly set hash value."
;;   `(setf (gethash ,obj ,hash) ,value))

(in-package #:ulquikit-tests)

(define-test test-macro-sethash
  (let ((hash (make-hash-table)))
    (sethash :first hash "hello")
    (sethash :second hash "world")
    (assert-equal "hello" (gethash :first hash))
    (assert-equal "world" (gethash :second hash))))

;; (run-tests '(test-macro-sethash))

(in-package #:ulquikit)

(defun snippet->string (snippet)
  "Returns the string representation of a snippet."
  (declare (snippet snippet))
  (get-snippet-content snippet))

;;; (snippet->string (make-snippet))

(in-package #:ulquikit-tests)

(define-test test-snippet->string
  (assert-equal "" (snippet->string (make-snippet)))
  (assert-equal "aoeu" (snippet->string (make-snippet :lines '("aoeu"))))
  (assert-equal "aoeu
ueoa"
                (snippet->string (make-snippet :lines '("aoeu" "ueoa")))))

;; (run-tests '(test-snippet->string))

(in-package #:ulquikit)

(defun get-all-adocs (path)
  "Retrieves all AsciiDoc files in `path' recursively.  TODO: Make this
extensible."
  (declare ((or string pathname) path))
  ;; (format t "Getting all adocs from path: ~A~%" path)
  (let ((adocs (list)))
    (cl-fad:walk-directory path #'(lambda (file)
                                    (push file adocs))
                           :directories nil
                           :if-does-not-exist :ignore
                           :test
                           #'(lambda (file)
                               (and
                                (null (scan "^(\\.|\\#)" (namestring file)))
                                (scan "\\.adoc$" (namestring file))))
                           :follow-symlinks t)
    adocs))

(in-package #:ulquikit-tests)

(define-test test-get-all-adocs
  (let* ((files '("a.adoc"
                  "b.adoc"
                  "c.md"
                  "e.adoc"
                  "hello/a.adoc"
                  "hello/b.html"
                  "hello/world/hola.adoc"
                  "hello/world/mundo.adoc"))
         (temppath (merge-pathnames "ulquikit/test-get-all-adocs/"
                                    (pathname (cl-fad:pathname-as-directory
                                               (uiop:getenv "TMPDIR")))))
         (expected (iterate
                     (for path in files)
                     (when (scan "\\.adoc$" path)
                       (collect (merge-pathnames path temppath))))))
    ;; Setup
    (cl-fad:delete-directory-and-files temppath
                                       :if-does-not-exist :ignore)
    (dolist (path files)
      (let ((file (merge-pathnames path temppath)))
        (ensure-directories-exist (path:dirname file))
        (with-open-file (out file :direction :output
                             :if-exists :supersede)
          (princ "Hello world" out))))

    (let ((adocs (get-all-adocs temppath)))
      (assert-equalp (sort expected #'(lambda (path1 path2)
                                        (string< (namestring path1)
                                                 (namestring path2))))
                     (sort adocs #'(lambda (path1 path2)
                                     (string< (namestring path1)
                                              (namestring path2))))))

    ;; Tear down
    (cl-fad:delete-directory-and-files temppath
                                       :if-does-not-exist :ignore)))

;; (run-tests '(test-get-all-adocs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

After `extract-snippets`, we need a function to include snippets into each
other.

anchor:section/include-snippets[]

=== Including snippets into each other

Let us call the function `include-snippet!`:

`include-snippet!` takes 2 arguments:
* the current list of snippets,
* a `(type . name)` cons representing the snippet being processed, this
  snippet must be a part of the current list of snippets,

This function returns the new list of snippets after included.

`include-snippet!` works by browsing the target snippet's content, one line at
a time, then replacing lines with `include::` directives with the
corresponding __code snippet__s in `snippets`.  If no snippet is found, the
line doesn't change.

Note that to prevent unnecessary copy, this function has side effects for all
of its arguments, hence its name is suffixed with a bang (`!`).

WARNING: The result of circular dependency, e.g. snippet A includes itself, is
*undefined*.  Make sure your snippets are well managed.

anchor:func/include-snippet[]

.code::include-snippet
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun include-snippet! (snippets type+name)
  "Processed target snippet by replacing all of its \"include\" directives
with the corresponding snippets found in `snippets'.  If the target snippet
introduces circular dependency, the result is undefined.  This function
modifies `snippets' in-place and returns it after processing."
  (declare (cons type+name) (snippets snippets))

  ;; (format t "→ including snippet ~A~%" type+name)

  ;; Ignore of the target snippet doesn't exist in the list of snippets
  (when (snippet-exists? type+name snippets)
    (let* ((target/type (car type+name))
           (target/name (cdr type+name))
           (target      (snippets/get-snippet snippets
                                              :type target/type
                                              :name target/name))
           (lines       (snippet/lines target))
           (lines-final (list)))
      ;; Also, we ignore if this snippet has already been processed
      (unless (snippet/processed? target)
        ;; Consider this snippet processed
        (setf (snippet/processed? target) t)

        ;; Now, recollect lines
        (dolist (line lines)
          ;; (format t "  Processing ~A~%" line)
          (if (include-directive? line)
              (let* ((includee-name (parse-include-directive line))
                     (includee      (snippets/get-snippet snippets
                                                          :type :code
                                                          :name includee-name)))
                (cond ((null includee)
                       ;; No such snippet to include
                       (push line lines-final))

                      ((snippet/processed? includee)
                       (push (snippet->string includee) lines-final))

                      ((not (snippet-exists? includee snippets))
                       (push line lines-final))

                      (t
                       (setf snippets (include-snippet!
                                       snippets
                                       `(:code . ,includee-name)))
                       (push (snippet->string includee) lines-final))))
            (push line lines-final)))

        ;; (format t "Snippet: ~A; result: ~A~%"
        ;;         (cdr type+name)
        ;;         (join-lines (reverse (copy-list lines-final))))

        ;; Then, collect result
        (setf (snippet/lines target)
              (list (join-lines (nreverse lines-final)))))))
  snippets)

(in-package #:ulquikit-tests)

;; (run-tests '(test-include-snippet))

(define-test test-include-snippet
  (let* ((snp/file (ulquikit::make-snippet :name "/tmp/tmp.lisp"
                                 :type :file
                                 :lines '(";; include::A"
                                          ";; The end")
                                 :linenum 10))
         (snp/code/A (ulquikit::make-snippet :name "A"
                                   :type :code
                                   :lines '("World"
                                            ";; include::B"
                                            ";; include::D")
                                   :linenum 20))
         (snp/code/B (ulquikit::make-snippet :name "B"
                                   :type :code
                                   :lines '("Hello")
                                   :linenum 30))
         (snp/code/C (ulquikit::make-snippet :name "C"
                                   :type :code
                                   :lines '("Not processed")
                                   :linenum 15))
         ;; Circular dependency
         (snp/code/D (ulquikit::make-snippet :name "D"
                                   :type :code
                                   :lines '(";; include A")
                                   :linenum 100))

         (snippets (let* ((res (ulquikit::make-snippets))
                          (ulquikit::snippets/file (ulquikit::snippets/file res))
                          (ulquikit::snippets/code (ulquikit::snippets/code res)))
                     (setf (gethash "/tmp/tmp.lisp" ulquikit::snippets/file) snp/file
                           (gethash "A" ulquikit::snippets/code) snp/code/A
                           (gethash "B" ulquikit::snippets/code) snp/code/B
                           (gethash "C" ulquikit::snippets/code) snp/code/C
                           (gethash "D" ulquikit::snippets/code) snp/code/D)
                     ;; Don't add D right away
                     res)))
    (setf snippets (ulquikit::include-snippet! snippets `(:code . "A")))
    (assert-true t)
    (assert-true (ulquikit::snippet/processed? snp/code/A))
    (assert-true (ulquikit::snippet/processed? snp/code/B))
    (assert-true (ulquikit::snippet/processed? snp/code/D))
    (assert-false (ulquikit::snippet/processed? snp/code/C))
    (assert-false (ulquikit::snippet/processed? snp/file))
    (assert-true (scan "^World\\nHello\\n"
                       (nth 0 (ulquikit::snippet/lines snp/code/A))))

    (setf snippets (ulquikit::include-snippet! snippets `(:file . "/tmp/tmp.lisp")))
    (let ((content (nth 0 (ulquikit::snippet/lines snp/file))))
      (assert-true (ulquikit::snippet/processed? snp/file))
      (assert-true (scan "^World\\nHello\\n" content))
      (assert-true (scan ";; The end$" content)))))

;; (run-tests '(test-include-snippet))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun snippet-exists? (snippet snippets)
  "Determines if the corresponding snippet is in `snippets'."
  (declare ((or snippet string cons) snippet)
           (snippets snippets))
  (typecase snippet
    ((or cons snippet)
     (let ((name (typecase snippet
                   (cons    (cdr snippet))
                   (snippet (snippet/name snippet))))
           (type (typecase snippet
                   (cons    (car snippet))
                   (snippet (snippet/type snippet)))))
       (case type
         (:code (not (null (gethash name (snippets/code snippets)))))
         (:file (not (null (gethash name (snippets/file snippets))))))))
    (string
     (or (not (null (gethash snippet (snippets/code snippets))))
         (not (null (gethash snippet (snippets/file snippets))))))))

(in-package #:ulquikit-tests)

(define-test test-snippet-exists?
  (let* ((code/a (make-snippet :name "a" :type :code))
         (code/b (make-snippet :name "b" :type :code))
         (file/a (make-snippet :name "a" :type :file))
         (file/b (make-snippet :name "b" :type :file))
         (snippets (let ((res (make-snippets)))
                     (sethash "a" (snippets/code res) code/a)
                     (sethash "a" (snippets/file res) file/a)
                     res)))
    (assert-eq t   (ulquikit::snippet-exists? code/a snippets))
    (assert-eq t   (ulquikit::snippet-exists? file/a snippets))
    (assert-eq t   (ulquikit::snippet-exists? "a"    snippets))
    (assert-eq t   (ulquikit::snippet-exists? `(:code . "a") snippets))
    (assert-eq t   (ulquikit::snippet-exists? `(:file . "a") snippets))
    (assert-eq nil (ulquikit::snippet-exists? `(:code . "b") snippets))
    (assert-eq nil (ulquikit::snippet-exists? code/b snippets))
    (assert-eq nil (ulquikit::snippet-exists? file/b snippets))
    (assert-eq nil (ulquikit::snippet-exists? "b"    snippets))))

;; (run-tests '(test-snippet-exists?))

(in-package #:ulquikit)

(defun include-directive? (line)
  "Determines of the corresponding line is a include directive.  TODO: Make this extensible."
  (declare (string line))
  (the boolean
       (let ((line (string-trim '(#\Space #\e #\t #\m) line)))
         (not (null (or (scan "^[#;/-]{2} include::.*" line)
                        (scan "^<!-- include::.* -->" line)
                        (scan "^/\\* include::.* \\*/" line)))))))

(in-package #:ulquikit-tests)

(define-test test-include-directive?
  (assert-eq t   (ulquikit::include-directive? "  ;; include::"))
  (assert-eq t   (ulquikit::include-directive? ";; include::"))
  (assert-eq nil (ulquikit::include-directive? "a;; include::"))
  (assert-eq t   (ulquikit::include-directive? ";; include::something"))
  (assert-eq t   (ulquikit::include-directive? "## include::something"))
  (assert-eq t   (ulquikit::include-directive? "// include::something"))
  (assert-eq t   (ulquikit::include-directive? "/* include::something */"))
  (assert-eq t   (ulquikit::include-directive? "<!-- include::something -->"))
  (assert-eq nil (ulquikit::include-directive? "a <!-- include::something -->")))

;; (run-tests '(test-include-directive?))

(in-package #:ulquikit)

(defun parse-include-directive (str)
  "Parses and extracts snippet name from an include directive.  See its tests
for detailed information on input/output format.  TODO: make this extensible."
  (declare (string str))
  (the
   string
   (if (include-directive? str)
       (let ((input (cond ((and (scan " -->$" str) (scan "^<!-- " str))
                           (subseq str 0 (- (length str) (length " -->"))))
                          ((and (scan " \\*/$" str) (scan "^/\\* " str))
                           (subseq str 0 (- (length str) (length " */"))))
                          (t
                           str))))
         (multiple-value-bind (_ name/array)
             (scan-to-strings "include::(.*)$" input)
           (declare (ignore _))
           (elt name/array 0)))
     "")))

(in-package #:ulquikit-tests)

(define-test test-include-directive
  (assert-equal "" (ulquikit::parse-include-directive "  ;; include::"))
  (assert-equal "" (ulquikit::parse-include-directive ";; include::"))
  (assert-equal "" (ulquikit::parse-include-directive
                    "a <!-- include::something -->"))
  (assert-equal "something" (ulquikit::parse-include-directive
                             ";; include::something"))
  (assert-equal "something" (ulquikit::parse-include-directive
                             "## include::something"))
  (assert-equal "something" (ulquikit::parse-include-directive
                             "// include::something"))
  (assert-equal "something" (ulquikit::parse-include-directive
                             "/* include::something */"))
  (assert-equal "something" (ulquikit::parse-include-directive
                             "<!-- include::something -->")))

;; (run-tests '(test-include-directive))

(in-package #:ulquikit)

(defun snippets/get-snippet (snippets &key
                                        (type :code)
                                        name)
  "Helper to quickly retrieve a snippet from a `snippets' struct."
  (declare (snippets snippets)
           (keyword  type)
           (string   name))
  (let ((hash (case type
                (:code (snippets/code snippets))
                (:file (snippets/file snippets))
                (otherwise (make-hash-table)))))
    (the (or boolean snippet) (gethash name hash))))

(in-package #:ulquikit-tests)

(define-test test-snippets/get-snippet
  (let* ((snp/code/a (make-snippet :type :code :name "a"))
         (snp/code/b (make-snippet :type :code :name "b"))
         (snp/file/c (make-snippet :type :file :name "c.lisp"))
         (snippets (let ((res (make-snippets)))
                     (sethash "a" (snippets/code res) snp/code/a)
                     (sethash "b" (snippets/code res) snp/code/b)
                     (sethash "c" (snippets/file res) snp/file/c)
                     res)))
    (assert-equal snp/code/a (ulquikit::snippets/get-snippet snippets
                                                             :type :code
                                                             :name "a"))
    (assert-equal snp/code/b (ulquikit::snippets/get-snippet snippets
                                                             :type :code
                                                             :name "b"))
    (assert-equal snp/file/c (ulquikit::snippets/get-snippet snippets
                                                             :type :file
                                                             :name "c"))))

;; (run-tests '(test-snippets/get-snippet))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

And that concludes the most important functions of Ulquikit.  Those are used
to implement the higher-level <<section/generate-source,`generate-src`>> right
below.

anchor:command/generate-src[]

=== Generating source code

`generate-src` generates source code from the `from` argument, which
representing a directory containing literate source files, to the `to`
argument, which denotes a directory containing the generated source code.  The
literate source files are retrieved recursively.

.code::generate-src
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun generate-src (&key (from "src")
                       (to "generated-src"))
  "Generates source code from all literate source files in `from' to directory
`to'.  `from' is either a directory or a single literate source file."
  (declare ((or string pathname) from to))
  (let* ((from     (uiop:merge-pathnames* from (uiop:getcwd)))
         (to       (uiop:merge-pathnames* to (uiop:getcwd)))
         (snippets (if (file? from)
                       (extract-snippets-from-file from)
                     (extract-snippets from))))
    ;; (format t "Generating src from: ~A to: ~A~%" from to)
    (write-src-files (include-file-snippets! snippets) to)))

;;; (generate-src :from "src/" :to "/tmp/ulquikit-test/")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun write-src-files (snippets to)
  "Writes all source snippets as files to `to'."
  (declare (snippets snippets)
           ((or string pathname) to))
  (iter (for (name snippet) in-hashtable (snippets/file snippets))
        (let ((path (uiop:merge-pathnames*
                     name
                     (uiop:merge-pathnames*
                      to
                      (uiop:getcwd))))
              (content (snippet->string snippet)))
          (format t "→ Writing ~A~%" path)
          (ensure-directories-exist path)
          (write-file path content))))

(defun write-file (path content)
  "Writes to a file."
  (declare ((or pathname string) path)
           (string content))
  (with-output-to-file (out path :if-exists :supersede)
    (format out "~A" content)))

(in-package #:ulquikit)

(defun file? (path)
  "Determines if path represents a file."
  (declare ((or string pathname) path))
  (the boolean
       (null (scan "/$" (namestring path)))))

(in-package #:ulquikit-tests)

(define-test test-file?
  (assert-true (file? "tmp.txt"))
  (assert-true (file? #p"tmp.txt"))
  (assert-false (file? "tmp.txt/"))
  (assert-false (file? #p"tmp.txt/")))

;; (run-tests '(test-file?))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
----

The ultimate goal of generating source code is to produce files, so we only
need to include other snippets into file snippets.  That's the job of
`include-file-snippets!` function.  This function takes a list of snippets (of
of `snippets` type) and returns an instance of `snippets` with all file
snippets <<section/include-snippets,included>>.

Note that for performance reason, this function is destructive, hence its name
is prefixed with a bang (``!``).

.code::include-file-snippets
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun include-file-snippets! (snippets)
  "Includes all file snippets in `snippets' and return a `snippets' with all
file snippets included.  This function is destructive, i.e. it modifies its
arguments."
  (declare (snippets snippets))
  (let ((file-snippets (snippets/file snippets)))
    (iter (for (name _) in-hashtable file-snippets)
          (include-snippet! snippets `(:file . ,name))))
  snippets)
----

And of course, we need help string for `generate-src` command that we'll talk
about right away:

.file::commands/generate-src.help.txt
[source,text,linenums]
----
ulqui generate-src [--from from] [--to to]

Generate source code from literate documents.

  --from   either path to a directory where literate documents are stored, or
           path to one literate document; default: "src/"
  --to     directory where source code are generated, default:
           "generated-src/"

Examples

Generate source code from src/ to generated-src/
  ulqui generate-src

or explitcitly
  ulqui generate-src --from src/ --to generated-src/

Generate source code from ../literate-source/ to ../source/
  ulqui generate-src --from ../literate-source/ --to ../source/

----

Once all functions are ready, let's put them together into a command to
generate source code.

.code::define-ulquikit-command-package
[source,lisp,linenums]
----
(defpackage #:ulquikit-cmd
  (:use :cl))
----

The `generate-src` command might look like so:

.file::commands/generate-src.lisp
[source,lisp,linenums]
----
;; include::license-header

(in-package #:ulquikit-cmd)

(defun generate-src (&key (from "src")
                          (to "generated-src"))
  "Command: generate source code."
  (declare ((or string pathname) from to))
  (display-command "Generating source")
  (ulquikit:generate-src :from from :to to))

(defun display-command (command &optional (stream t))
  "Displays a command."
  (declare (string command)
           ((or stream boolean) stream))
  (format stream "==== ~A ====~%" command))

----

That is how a command should be defined.  Let's generalize this idea for other
commands.

== Anatomy of a Ulquikit command

Following convention over configuration principle, Ulquikit commands are
automatically loaded.  A command is actually a Common Lisp package, residing
in `commands/` directory.  Each has `help` and `run` functions, which are
called when user runs the command or gets help respectively.  Should one of
the function does not exist, the correponding action does nothing.

Commands are loaded in the alphabetical order of their source code files.
This way, one can override commands by adding another definition to load later
than its original version.  E.g. if command `extract-text` is defined in
`commands/extract-text.lisp` and command `help` is defined in
`commands/help.lisp`, `extract-text` is loaded before `help` as
`commands/extract-text.lisp` precedes `commands/help.lisp` alphabetically.  If
`extract-text` is once again defined/modified in
`commands/z-extract-text.lisp`, those changes override
`commands/extract-text.lisp` as `commands/z-extract-text.lisp` comes after
`commands/extract-text.lisp` in alphabetical order.

More details of command invocation:

* Command line arguments are parsed and passed through `run` function.
+
E.g.

** `ulqui generate-src` calls `run` function of `generate-src` package.  This
   function might be private.  It's recommended to make it public, though.

** `ulqui generate-src some-file` calls `(generate-src:run "some-file")` or
   `(generate-src::run "some-file")`, depending on the visibility of `run`.

** `ulqui generate-src --from file1 --to file2` calls `(generate:run :from
   "file1" :to "file2")` or `(generate::run :from "file1" :to "file2"),
   depending on the visibility of `run`.

* When `ulqui help command-name` or `ulqui command-name --help` is invoked,
  `command-name:help` or `command-help::help` (depending on the visibility of
  `help` function in `command-name` package) is called.  The `help` function
  takes no arguments and returns a string that would be displayed as help.

* Documentation of a command is stored in docstring of the `run` function of
  the corresponding command.

* All command packages must use `command-core` package.

Let's move on to the function to parse command line arguments.

=== Parsing command line arguments with `parse-command-args`

This function takes all arguments passed to the command line as a list of
string and returns an alist of the following format:

[source,lisp,linenums]
----
((:arguments . list-of-arguments) <1>
 (:options   . alist-of-options)) <2>
----

<1> main arguments collected as a list, with the same order as they are at the
command line
<2> options are collected as alist; options that have no values are set to `t`

In Ulquikit, options are prefixed with one or two dashes (`-` or `--`), while
arguments are not.  Option values are attempted to parse as number or
boolean (e.g. in case of ``1``, ``t``, ``true``, ``false``, ...).

The `command-core` package and its test counterpart could be declared as
followed:

.code::define-command-core-package
[source,lisp,linenums]
----
(in-package #:cl)

(defpackage #:command-core
  (:use :cl :iterate)
  (:export #:parse-cmd-args
           #:argument?
           #:option?
           #:option->keyword
           #:run-cmd
           #:help))

(defpackage #:command-core-tests
  (:use :cl :lisp-unit))

(setf lisp-unit:*print-failures* t
      lisp-unit:*print-errors*   t)
----

.code::parse-command-line-arguments
[source,lisp,linenums]
----
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun parse-cmd-args (args)
  (let ((arguments (take-while #'argument? args))
        (rest-args (drop-while #'argument? args)))
    (labels ((parse-options (rest-args current-opts)
               (declare (list rest-args current-opts))
               (if (null rest-args)

                   ;; No more option to parse
                   current-opts

                 (let* ((option-name   (first rest-args))
                        (option-values (take-while #'argument? (rest rest-args)))
                        (rest-args     (drop-while #'argument? (rest rest-args)))

                        (option-values/converted (mapcar #'try-convert-value option-values))
                        (option-name/keyword     (option->keyword option-name))

                        (option-values/res
                         (cond
                           ((null option-values)         ;; --help → (:help . t)
                            t)

                           ((= 1 (length option-values)) ;; --help a → (:help . "a")
                            (first option-values/converted)) ;

                           (t                            ;; --help a b → (:help . ("a" "b"))
                            option-values/converted)))

                        (new-option (cons option-name/keyword option-values/res)))
                   (parse-options rest-args
                                  (push new-option
                                        current-opts))))))
      `((:arguments . ,arguments)
        (:options   . ,(parse-options rest-args (list)))))))

(in-package #:command-core-tests)

(define-test test-parse-cmd-args
  (assert-equal `((:arguments . ())
                  (:options   . ()))
                (parse-cmd-args '()))
  (assert-equal `((:arguments . ("hello-world"))
                  (:options   . ()))
                (parse-cmd-args '("hello-world")))
  (assert-equal `((:arguments . ("hello" "world"))
                  (:options   . ()))
                (parse-cmd-args '("hello" "world")))
  (assert-equal `((:arguments . ())
                  (:options   . ((:help . t))))
                (parse-cmd-args '("--help")))
  (assert-equal `((:arguments . ("hello"))
                  (:options   . ((:help . t))))
                (parse-cmd-args '("hello" "--help")))
  (assert-equal `((:arguments . ("hello"))
                  (:options   . ((:help . ("world" "args")))))
                (parse-cmd-args '("hello" "--help" "world" "args")))
  (assert-equal `((:arguments . ())
                  (:options   . ((:help . "hello"))))
                (parse-cmd-args '("--help" "hello")))
  (assert-equal `((:arguments . ("hello" "world"))
                  (:options   . ((:set-tab . 4)
                                 (:help    . t))))
                (parse-cmd-args '("hello" "world" "--help" "--set-tab" "4"))))

;; (run-tests '(test-parse-cmd-args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun take-while (fn xs)
  "Takes each `item' of `xs' from the beginning and builds a list until
`\(funcall fn item\)' returns `nil'.

E.g.

  \(take-while #'oddp '\(\)\)          ;; ⇨ '\(\)
  \(take-while #'oddp '\(2 3 4\)\)     ;; ⇨ '\(\)
  \(take-while #'evenp '\(2 2 4\)\)    ;; ⇨ '\(2 2 4\)
  \(take-while #'evenp '\(2 2 1 3\)\)  ;; ⇨ '\(2 2\)"
  (declare (function fn) (sequence xs))
  (the list (iterate (for x in xs)
                     (while (funcall fn x))
                     (collect x))))

(in-package #:command-core-tests)

(define-test test-take-while
  (assert-equal '()      (command-core::take-while #'oddp '()))
  (assert-equal '()      (command-core::take-while #'oddp '(2 3 4)))
  (assert-equal '(2 2 4) (command-core::take-while #'evenp '(2 2 4)))
  (assert-equal '(2 2)   (command-core::take-while #'evenp '(2 2 1 3))))

;; (run-tests '(test-take-while))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun drop-while (fn xs)
  "Starting from the first item of `xs' that `\(funcall fn item\)' returns
`nil', builds a list with the rest of `xs'.

E.g.

  \(drop-while #'oddp '\(\)\)            ;; ⇨ '\(\)
  \(drop-while #'oddp '\(1 1 5 7\)\)     ;; ⇨ '\(\)
  \(drop-while #'oddp '\(1 2 5 2 3 4\)\) ;; ⇨ '\(2 3 4\)
  \(drop-while #'oddp '\(2 3 4\)\)       ;; ⇨ '\(2 3 4\)"
  (declare (function fn) (sequence xs))
  (the list (labels ((helper (xs)
                       (cond ((null xs)
                              (list))
                             ((not (funcall fn (first xs)))
                              xs)
                             (t
                              (helper (rest xs))))))
              (helper xs))))

(in-package #:command-core-tests)

(define-test test-drop-while
  (assert-equal '()      (command-core::drop-while #'oddp '()))
  (assert-equal '()      (command-core::drop-while #'oddp '(1 1 5 7)))
  (assert-equal '(2 3 4) (command-core::drop-while #'oddp '(1 1 5 2 3 4)))
  (assert-equal '(2 3 4) (command-core::drop-while #'oddp '(2 3 4))))

;; (run-tests '(test-drop-while))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun argument? (str)
  "Determines if a string is considered an argument.  An argument is not
prefixed with a dash \"-\"."
  (declare (string str))
  (the boolean (not (alexandria:starts-with #\- str))))

(in-package #:command-core-tests)

(define-test test-argument?
  (assert-equal t   (argument? ""))
  (assert-equal t   (argument? "a"))
  (assert-equal nil (argument? "-a"))
  (assert-equal nil (argument? "--a"))
  (assert-equal nil (argument? "-")))

;; (run-tests '(test-argument?))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun option? (str)
  "Determines if a string is considered an option.  An option is prefixed with
a dash \"-\"."
  (declare (string str))
  (the boolean (not (argument? str))))

(in-package #:command-core-tests)

(define-test test-option?
  (assert-equal nil (option? ""))
  (assert-equal nil (option? "a"))
  (assert-equal t   (option? "-a"))
  (assert-equal t   (option? "--a"))
  (assert-equal t   (option? "-")))

;; (run-tests '(test-option?))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun option->keyword (opt)
  "Converts option as string to Common Lisp keyword."
  (declare ((or symbol string) opt))
  (the keyword
       (typecase opt
         (keyword opt)
         (symbol  (intern (symbol-name opt) :keyword))
         (string  (multiple-value-bind (_ xs)
                      (cl-ppcre:scan-to-strings "^-+(.+)$" opt)
                    (declare (ignore _))
                    (if (zerop (length xs))
                        (error "~S is not a valid option" xs)
                        (intern (string-upcase (aref xs 0)) :keyword)))))))

(in-package #:command-core-tests)

(define-test test-option->keyword
  (assert-equal :h       (option->keyword "-h"))
  (assert-equal :help    (option->keyword "--help"))
  (assert-equal :help    (option->keyword "---help"))
  (assert-equal :help-me (option->keyword "---help-me")))

;; (run-tests '(test-option->keyword))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun try-convert-value (value)
  "Tries converting a string value as number, boolean, or returns itself."
  (declare (string value))
  (cond ((string-equal "true" value) t)
        ((string-equal "false" value) nil)
        ((string-equal "t" value) "t")
        ((string-equal "nil" value) "nil")
        (t (let ((res (read-from-string value)))
             (if (numberp res)
                 res
               value)))))

(in-package #:command-core-tests)

(define-test test-try-convert-value
  (assert-equal 1    (command-core::try-convert-value "1"))
  (assert-equal "a"  (command-core::try-convert-value "a"))
  (assert-equal t    (command-core::try-convert-value "true"))
  (assert-equal t    (command-core::try-convert-value "true"))
  (assert-equal nil  (command-core::try-convert-value "false")))

;; (run-tests '(test-try-convert-value))
----

=== Calling corresponding command

.code::run-command
[source,lisp,linenums]
----
(in-package #:command-core)

(defun run-cmd (cmd args)
  "Runs command with appropriate arguments by calling the `run' function in
the corresponding package."
  (declare ((or string symbol package) cmd)
           (list args))
  (let ((func (get-function "RUN" cmd)))  ; TODO: make this extensible
    (funcall func args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun get-function (func &optional (package *package*))
  "Retrieves a function from a package or throws error if not found."
  (declare ((or string symbol function) func)
           ((or string symbol package) package))
  (let* ((package (find-package (typecase package
                                  (string (string-upcase package))
                                  (otherwise package))))
         (func (typecase func
                 (string    (fdefinition
                             (find-symbol (string-upcase func)
                                          package)))
                 (symbol    (fdefinition
                             (find-symbol (symbol-name func)
                                          package)))
                 (otherwise func))))
    func))

(in-package #:command-core-tests)

(define-test test-get-function
  (assert-equal #'command-core:run-cmd (command-core::get-function "RUN-CMD" "COMMAND-CORE"))
  (assert-equal #'command-core:run-cmd (command-core::get-function 'run-cmd "COMMAND-CORE"))
  (assert-equal #'command-core:run-cmd (command-core::get-function :run-cmd :command-core))
  (assert-error 'undefined-function (command-core::get-function :doesnt-exist :command-core)))

;; (run-tests '(test-get-function))
----

We also have `run-help` to display help of a command.  `run-help` simply reads
the help file of the corresponding command and returns its content.

.code::run-command-help
[source,lisp,linenums]
----
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:command-core)

(defun help (cmd)
  "Reads and returns the help of a command, which is the documentation string
of the corresponding function."
  (declare ((or string symbol package) cmd))
  (let* ((cmd-package (find-package (typecase cmd
                                      (string (string-upcase cmd))
                                      (otherwise cmd))))
         (run-func    (intern "RUN" cmd-package))) ; TODO: make this
                                                   ; extensible
    (format t "~A~%" (documentation run-func 'function))))

(defpackage #:foobar-help
  (:use :cl)
  (:export #:run))

(in-package #:foobar-help)

(defun run ()
  "A function with documentation string as help."
  t)

(in-package #:command-core-tests)

(define-test test-help
  (let* ((output (make-string-output-stream))
         (*standard-output* output))
    (help "foobar-help")
    (assert-equal "A function with documentation string as help.
"
                  (get-output-stream-string output))))

;; (run-tests '(test-help))

----

=== Putting all command helpers together

.file::command-core.lisp
[source,lisp,linenums]
----
;; include::license-header

;; include::define-command-core-package

;; include::run-command

;; include::run-command-help

;; include::parse-command-line-arguments

(in-package #:command-core)

(defun display-cmd (msg)
  "Nicely formats and displays a command."
  (format t "==== ~A ====~%" msg))

----

Next, we are going to talk about the `generate-html` command, which generates
HTML documents with some default options.

== Generating HTML

.code::generate-html/documentation
[source,lisp,linenums]
----
  "Usage: generate-html [--from from] [--to to]

Generate HTMLs from literate documents.

  --from   either path to a directory where literate documents are stored, or
           path to one literate document, default: \"src\"

  --to     directory where HTMLs are generated, default: \"generated-html\"

Examples

Generate HTMLs from src/ to generated-html/ recursively
  ulqui generate-html

or explicitly
  ulqui generate-html --from src/ --to generated-html/

Generate HTMLs from literate-source/ to generated-documents/
  ulqui generate-html \\
    --from literate-source/ \\
    --to generated-documents
"
----

=== Defining package

.file::commands/generate-html.lisp
[source,lisp,linenums]
----
(defpackage #:ulqui/generate-html
  (:use :cl :cl-cwd)
  (:export #:run))

(defpackage #:ulqui/generate-html-tests
  (:use :cl :lisp-unit))

(in-package #:ulqui/generate-html)

;; include::generate-html/run

;; include::generate-html/render-asciidoc
----

=== The main function

.code::generate-html/run
[source,lisp,linenums]
----
(in-package #:ulqui/generate-html)

(defun run (&key (from "src")
              (to "generated-html"))
  ;; include::generate-html/documentation
  (let* ((from (full-path from))
         (to   (full-path to))
         (docs (list-all-adocs from)))
    (cl-cwd:with-cwd from
      (dolist (doc docs)
        (uiop:ensure-all-directories-exist (list to))
        
        ;; merge-pathnames actually replaces the extension
        (render-asciidoc doc (uiop:merge-pathnames*
                              (html-namepart doc)
                              to))))))

;; include::

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulqui/generate-html)

(defun html-namepart (file)
  "Extracts only the name part of the file and replaces its extension with
HTML."
  (declare ((or string pathname) file))
  (let* ((file (namestring (path:basename file)))
         (last-dot (search "." file :from-end t))
         (namepart-only (if last-dot
                            (subseq file 0 last-dot)
                          file)))
    (the string (format nil "~A.html" namepart-only))))

(in-package #:ulqui/generate-html-tests)

(define-test test-html-namepart
  (assert-equal "hello.html" (ulqui/generate-html::html-namepart "/tmp/hello"))
  (assert-equal "hello.html" (ulqui/generate-html::html-namepart "/tmp/hello.adoc"))
  (assert-equal "hello.html" (ulqui/generate-html::html-namepart "/tmp/hello.txt")))

;; (run-tests '(test-html-namepart))
----

=== Rendering a ASCIIDoc document to HTML

.code::render-asciidoc
[source,lisp,linenums]
----
(in-package #:ulqui/generate-html)

(defun asciidoctor-command (input output)
  "Builds and returns command to render `input' to `output' with ASCIIDoctor."
  (declare ((or string pathname) input output))
  (the string (format nil "asciidoctor ~A -d book -o ~A" input output)))

(defun render-asciidoc (input output)
  "Renders an ASCIIDoc `input' to `output' as HTML.  TODO: make this
extensible."
  (format t "→ ~A ⇨ ~A~%" input output)
  (!cmd (asciidoctor-command input output)))

(defun !cmd (cmd &key (output t)
                 (error-output t)
                 (force-shell t))
  "Runs command by calling `uiou:run-program'."
  (declare (string cmd)
           (boolean force-shell)
           ((or boolean stream) output error-output))
  (uiop:run-program cmd :output output
                    :error-output error-output
                    :force-shell force-shell))

----

=== Listing all ASCIIDoc documents in a directory

.code::generate-html/list-asciidocs
[source,lisp,linenums]
----
(in-package #:ulqui/generate-html)

(defun list-all-adocs (path &key (recursive t))
  "Returns a list of all ASCIIDoc file (i.e. file with .adoc or .txt
extensions) from directory `path', ignoring all temporary files.  TODO: Make
this extensible."
  (declare ((or string pathname) path)
           (ignore recursive))
  (labels ((valid? (path)
             (let ((path (namestring path)))
               (and (not (cl-fad:directory-pathname-p path))
                    (cl-ppcre:scan "^[^#]" path)
                    (cl-ppcre:scan "\\.(adoc|txt|asciidoc)$" path)))))
    (let ((result (list)))
      (cl-fad:walk-directory path
                             #'(lambda (file) (push file result))
                             :test #'valid?)
      result)))

----

=== Retrieving full path

.code::generate-html/full-path
[source,lisp,linenums]
----
(in-package #:ulqui/generate-html)

(defun full-path (path)
  "Returns absolute path."
  (declare ((or string pathname) path))
  (uiop:merge-pathnames* path (cl-cwd:cwd)))

----


And last but not least, for +generate-html+ to be ready, we need a function to
extract file name and replace +.adoc+ extension with +.html+ extension.

.code::get-output-file
[source,racket,linenums]
----
(define get-output-file
  #λ(~> (file-name-from-path %)
      path->string
      (string-replace ".adoc" ".html")))

(module+ test
  (check-equal? (get-output-file "/tmp/tmp.adoc")   "tmp.html")
  (check-equal? (get-output-file "/tmp/world.adoc") "world.html"))

----

The code for command +generate-html+ is as simple as followed:

.file::commands/generate-html.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

(module+ test
  (require rackunit))

;; include::render-asciidoc

;; include::get-output-file

;; include::generate-html

(define (run #:from [from "src"]
             #:to   [to   "generated-html"])
  (display-command "Generating HTML")
  (generate-html #:from from
                 #:to   to))

----

== The +ulqui+ script

So far we have been going through all important internal components of
Ulquikit.  What's left to make a complete, usable application is the main
command that takes care of user interactive: the +ulqui+ script.  +ulqui+ is a
complete Racket module.

First and foremost, this module should be able to detect all built-in commands
residing in +commands/+ directory.  This task is simple and straightforward:
find all +.rkt+ files is +commands/+ directory and return them as a list
without their extensions.

.code::ulqui/list-commands
[source,racket,linenums]
----
(define (list-commands)
  (let* ([command-dir (get-path +ulqui-dir+ "../commands/")]
         [commands    (~>> (directory-list command-dir)
                        (map path->string)
                        (filter #λ(string-ends-with? % ".rkt"))
                        (map #λ(regexp-replace #px"\\.rkt$" % "")))])
    commands))

----

+ulqui+ might be liked, or copied indenpently, so the help of +ulqui+ should
should be within in source.  Besides, whenever help is called, +ulqui+ should
be able to detect all available commands and brief their helps.

.code::ulqui/display-help
[source,racket,linenums]
----
(define (display-help)
  (displayln
   @str{Usage: ulqui <command> [options] ...

Ulquikit is yet another literate programming tool, with the main tasks of
generating code and documentation from literate source.

Supported markup language: AsciiDoc.
Supported output formats for documentation: HTML.

Available commands:

})
  (let* ([commands   (list-commands)]

         [full-helps (map #λ(with-output-to-string
                              (λ ()
                                (run-help %))) commands)]

         [helps      (for/list ([text full-helps])
                       (let* ([lines (string-split text "\n" #:trim? #f)]
                              [usage-omitted (dropf lines
                                                    #λ(not (string=? % "")))]
                              [help (takef (rest usage-omitted)
                                           #λ(not (string=? % "")))])
                         (string-join help "\n")))])
    (map (λ (command help)
           (displayln (str (format (~a command
                                       #:width 15))
                           " :: "
                           help)))
         commands
         helps))
  (newline)
  (displayln
   @str{
Use 'ulqui help' or 'ulqui --help' to bring up this help.
Use 'ulqui help <command>' or 'ulqui <command> --help' to get help for a
command.
Use 'ulqui --version' to display current running version of Ulquikit.})
  (newline))

----

One important thing to note is that +ulqui+ script might be linked to and run
from different places.  Once it has been linked, Ulquikit directory is not the
directory that contains this script anymore, thus it needs to be re-calculated
and all functions which are imported need to be ++require++d manually:

.code::ulqui/require-utils
[source,racket,linenums]
----
(define +ulqui-script-path+
  (resolve-path (syntax-source #'here)))

(define +ulqui-dir+
  (let-values ([(base name must-be-dir?)
                (split-path +ulqui-script-path+)])
    base))

(define get-ulqui-module-path
  #λ(build-path +ulqui-dir+ %))

(define +ulquikit-version+
 (dynamic-require (get-ulqui-module-path "../ulquikit.rkt")
                  '+ulquikit-version+))

(define string-ends-with?
 (dynamic-require (get-ulqui-module-path "../utils/string.rkt")
                  'string-ends-with?))

(define get-path
  (dynamic-require (get-ulqui-module-path "../utils/path.rkt")
                   'get-path))

(define run-help
  (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                   'run-help))

(define run-command
 (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                  'run-command))
----


Putting all things mentioned above together, we have the following +ulqui+
script.  To make the script as practical as possible, certain things should be
clarified:

* By default, running +ulqui+ alone usually means users need some help.  Thus
  running +ulqui+ is equivalent to running +ulqui help+.

* If users execute invalid command, this script also fallbacks to +ulqui
  help+ with a small error message.

.file::bin/ulqui
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

;; include::ulqui/display-version

;; include::ulqui/require-utils

;; include::ulqui/list-commands

;; include::ulqui/display-help

(module+ main
  (void
   (let* ([command-list (list-commands)]
          [arguments (vector->list (current-command-line-arguments))]
          [arg-list  (if (empty? arguments)
                         '("help")
                         arguments)]
          [command   (first arg-list)]
          [args      (rest arg-list)])
     (cond [(string=? "help" command)
            (if (empty? args)
                (display-help)
                (run-help (first args)))]
           [(string=? "--version" command)
            (display-version)]
           [(not (member command command-list))
            (displayln (str "-> Invalid command " command ".\n"))
            (display-help)]
           [else
            (run-command command args)]))))

----

Oh, and let's not forget this small but useful function: +display-version+

.code::ulqui/display-version
[source,racket,linenums]
----
(define (display-version)
  (displayln (str "Ulquikit v" +ulquikit-version+)))
----


== Managing Ulquikit source code

As Ulquikit grows, the need for a script/tool to manage source code,
release, ... arises.  This +schiffer+ script (named after last name of
http://en.wikipedia.org/wiki/List_of_Hollows_in_Bleach#Ulquiorra_Schiffer[Ulquiorra
Schiffer]) is born to fulfilled that need.

=== Generate source code and HTML documents, all at once

This function simply makes a call to <<command/generate-src,+generate-src+>>
and <<command/generate-html,generate-html>> commands.  Note that the
+schiffer+ script only has its use inside Ulquikit project, so when it's
generated, it's moved outside +generated-src+.  Also, all files in
+generated-src/bin/+ directory should be given executable permission.

.code::schiffer/generate-all
[source,racket,linenums]
----
(define (generate-src)
  (system "ulqui generate-src")

  (displayln "=> Giving executable permission to generated-src/bin/*")
  (system "chmod +x generated-src/bin/*")
  (newline)

  (displayln "=> Moving schiffer to current directory")
  (rename-file-or-directory "generated-src/bin/schiffer"
                            "schiffer-dev"
                            #t)
  (displayln "   generated-src/bin/schiffer => ./schiffer-dev")
  (newline)

  (displayln "=> Moving quick installation script to current directory")
  (rename-file-or-directory "generated-src/bin/quick-install.sh"
                            "quick-install.sh"
                            #t)
  (displayln "   generated-src/bin/quick-install.sh => ./quick-install.sh")
  (newline))

(define (generate-html)
  (system "ulqui generate-html")
  (newline))

(define (generate-all)
  (generate-src)
  (generate-html))

----

=== Update-self

This function simply copy and replace +schiffer+ script with +schiffer-dev+
without re-generating source code.

.code::schiffer/update-self
[source,racket,linenums]
----
(define (update-self)
  (displayln "=> Replacing schiffer with schiffer-dev")
  (copy-file "schiffer-dev" "schiffer" #t)
  (displayln "   ./schiffer-dev -> ./schiffer")
  (newline))

----

=== Mark current source as stable

Marking current generated source code as stable by replacing
+release/ulquikit+ with +generated-src+.  Note that this function/command does
*not* re-generate source code.

.code::schiffer/mark-stable
[source,racket,linenums]
----
(define (mark-stable)
  (displayln "=> Removing current stable")
  (delete-directory/files "release" #:must-exist? #f)
  (newline)

  (displayln "=> Creating stable directory: release")
  (make-directory* "release")
  (newline)

  (displayln "=> Copying current generated source to stable")
  (displayln "   generated-src -> release/ulquikit")
  (copy-directory/files "generated-src" "release/ulquikit")
  (newline)

  (displayln "=> Copying docs")
  (displayln "   generated-html -> release/ulquikit/docs")
  (copy-directory/files "generated-html" "release/ulquikit/docs")
  (newline))

----

=== Release

[[schiffer/mark-release]]
.code::schiffer/mark-release
[source,racket,linenums]
----
(define (mark-release)
  (mark-stable)
  (let* ([latest-tag       (~> (process "git tag")
                             first
                             port->string
                             string-split
                             last)]
         [filename         (format "ulquikit-~a.zip" latest-tag)]
         [zip-command      (format "zip -r ~a ulquikit" filename)]
         [checksum-command (format "md5sum ~a > ~a.md5"
                                   filename
                                   filename)])
    (parameterize [(current-directory "release")]
      (displayln (str "=> Creating release/" filename))
      (system zip-command)
      (newline)

      (displayln (str "=> Creating checksum for release/" filename))
      (system checksum-command)
      (displayln (str "   release/" filename " => release/" filename ".md5"))
      (newline))))

----


=== Run current dev version of Ulquikit

Running current Ulquikit dev version is done by calling
+generated-src/bin/ulqui+.

.code::schiffer/ulqui-dev
[source,racket,linenums]
----
(define (ulqui-dev args)
  (system (str "generated-src/bin/ulqui "
               (~> (map #λ(string-append "'" % "'") args)
                 (string-join " "))))
  (newline))

----

=== Run tests

By calling +raco test generated-src/*+.

.code::schiffer/run-tests
[source,racket,linenums]
----
(define (run-tests)
  (system "raco test generated-src/*")
  (newline))

----

=== Clean up

Simply removing +generated-html+ and +generated-src+ directories:

.code::schiffer/clean-up
[source,racket,linenums]
----
(define (clean-up)
  (displayln "=> Removing generated-html")
  (delete-directory/files "generated-html" #:must-exist? #f)
  (displayln "=> Removing generated-src")
  (delete-directory/files "generated-src" #:must-exist? #f)
  (newline))
----

=== Help

Of course, help is particularly useful.

.code::schiffer/help
[source,racket,linenums]
----
(define (help)
  (displayln @str{
Usage: schiffer <command> [options] ...

Schiffer is a simple build script for Ulquikit.

Available commands:

  generate-src  :: Generate Ulquikit source code to 'generated-src'.
  generate-html :: Generate Ulquikit HTML docs to 'generated-html'.
  generate-all  :: Call 'generate-src', then 'generate-html'.
  update-self   :: Update Schiffer, replace itself with './schiffer-dev'.
  mark-stable   :: Mark current 'generated-src' as stable by copying it into
                   'release/ulquikit'
  mark-release  :: Mark current stable in 'release/ulquikit' as release by
                   zipping it with latest Git tag name.  E.g.
                  'release/ulquikit' is zipped into 'release/ulquikit-v2.0.zip'.
  ulqui-dev     :: Analogous to 'generated-src/bin/ulqui'.
  clean-up      :: Clean up generated source and HTML.
  run-tests     :: Run all Ulquikit tests in 'generated-src/'.
  help          :: Print this help.

Note that only 'ulqui-dev' takes options.
})
  (newline))

----


=== Combine into +schiffer+

.file::bin/schiffer
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

(require net/url)

;; include::schiffer/generate-all

;; include::schiffer/update-self

;; include::schiffer/mark-stable

;; include::schiffer/mark-release

;; include::schiffer/ulqui-dev

;; include::schiffer/clean-up

;; include::schiffer/run-tests

;; include::schiffer/help

(module+ main
  (void
   (let* ([args    (current-command-line-arguments)]
          [command (vector-ref (if (zero? (vector-length args))
                                   #("")
                                   args)
                               0)])
     (match command
       ["generate-src"     (generate-src)]
       ["generate-html"    (generate-html)]
       ["clean"            (clean-up)]
       ["update-self"      (update-self)]
       ["mark-stable"      (mark-stable)]
       ["mark-release"     (mark-release)]
       [(or "ulqui-dev"
            "run-dev")     (ulqui-dev (vector->list (vector-drop args 1)))]
       [(or "test"
            "run-tests")   (run-tests)]
       [(or "generate-all"
            "build")       (generate-all)]
       [_                  (help)]))))
----

== Updating Ulquikit

As more versions of Ulquikit are released, having a way to update Ulquikit
from the command line is very helpful.  One way to do this is by adding
+update+ command, so that users could update Ulquikit to latest version just
by running:

[source,sh]
----
ulqui update
----

=== Retrieve latest version

Ulquikit is officially released via
https://help.github.com/articles/about-releases[Github Releases], which
provides this URL https://github.com/cmpitg/ulquikit/releases/latest pointing
to latest release.

First of all, let's +curl+ this URL to see how it's redirected:

[source,sh,linenums]
----
curl --head https://github.com/cmpitg/ulquikit/releases/latest

# HTTP/1.1 302 Found
# Server: GitHub.com
[snip]
# Location: https://github.com/cmpitg/ulquikit/releases/tag/v0.2
[snip]
----

So that's how it works, simple and straightforward.  The job now is to get the
"Location" attribute from HTTP header and grab the version.  With Racket's
http://docs.racket-lang.org/net/url.html[+net/url+] library, it becomes trivial:

.code::ulqui/latest-version
[source,racket,linenums]
----
(define +latest-release-url+
  (string->url "https://github.com/cmpitg/ulquikit/releases/latest"))

(define (get-latest-version)
  (~> (call/input-url +latest-release-url+
                      head-impure-port
                      port->string)
    string-split
    (dropf #λ(not (string=? "Location:" %)))
    second
    (#λ(regexp-match #rx"v(.*)" %))
    second))

----

Note that we use
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-impure-port%29%29[+head-impure-port+]
instead of
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-pure-port%29%29[+head-pure-port+]
as the response might content body.

=== Download and replace Ulquikit

==== Construct download URL

Let's have a closer look: Version 2.0 has
https://github.com/cmpitg/ulquikit/releases/download/v0.2/ulquikit-v0.2.zip as
its download URL.  The filename +ulquikit-v0.2.zip+ certainly depends on
naming convention, which <<schiffer/mark-release,+schiffer+>> has got us
covered.  So all download URLs follow the following format:
+https://github.com/cmpitg/ulquikit/releases/download/v{latest-version}/ulquikit-v{latest-version}.zip+.
Based on that, we have this function to construct download URL of the latest
version:

.code::ulqui/construct-download-url
[source,racket,linenums]
----
(define (construct-download-url [version (get-latest-version)])
  (format "https://github.com/cmpitg/ulquikit/releases/download/v~a/ulquikit-v~a.zip"
          version
          version))
----

==== Download and unzip

There are a couple of ways to download and unzip the release file, among which
the following 2 are the most commonly used:

* Using Racket's own API - bad in performance and memory space.

* Calling shell commands - platform-dependant but much better in performance.

Let's make this work first then improve later.  I'm going to choose the 2^nd^
option for now.

Note that +system+ is used to call external commands, which in turn produce
some data to standard output and standard error.  Thus we make standard output
and standard error unbeffered during to +system+ call to achieve the best
result.

.code::ulqui/download-and-unzip
[source,racket,linenums]
----
(define (download-and-unzip version to-dir)
  (parameterize ([current-directory to-dir])
    (let ([url              (construct-download-url version)]
          [filename         (format "ulquikit-v~a.zip" version)]
          [out-buffer-mode  (file-stream-buffer-mode (current-output-port))]
          [err-buffer-mode  (file-stream-buffer-mode (current-error-port))])

      (with-handlers ([exn:fail?
                       (λ (_)
                         (file-stream-buffer-mode (current-output-port)
                                                  out-buffer-mode)
                         (file-stream-buffer-mode (current-error-port)
                                                  err-buffer-mode))])
        (file-stream-buffer-mode (current-output-port) 'none)
        (file-stream-buffer-mode (current-error-port) 'none)

        (displayln (str "-> Downloading from " url))
        (system (str "curl -O " url))

        (displayln (str "-> Unzipping " filename ", replacing old version with new version"))
        (system (str "unzip -o " filename))

        (displayln (str "-> Removing " filename))
        (delete-directory/files filename)

        (file-stream-buffer-mode (current-output-port) out-buffer-mode)
        (file-stream-buffer-mode (current-error-port) err-buffer-mode)))))

----

=== The +update+ command

.file::commands/update.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require net/url)

(require "../ulquikit.rkt")
(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

;; include::ulqui/latest-version

;; include::ulqui/construct-download-url

;; include::ulqui/download-and-unzip

(define (run)
  (display-command "Updating Ulquikit")
  (displayln (str "-> Current version: " +ulquikit-version+))
  (let ([latest-version (get-latest-version)])
    (displayln (str "   Latest version:  " latest-version))
    (cond [(string=? latest-version +ulquikit-version+)
           (newline)
           (displayln (str "   Congratulations! You are running the latest version of Ulquikit!"))]
          [else
           (download-and-unzip latest-version +ulquikit-location+)])))

----

Of course, a little piece of help text is always necessary.

.file::commands/update.help.txt
[source,text,linenums]
----
Usage: update

Update Ulquikit to latest version.

----

== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

=== Quick installation script

This comes in handy at times.  The script assumes that *users have already
installed Racket and Ruby*.

The user-friendliness provided by the script is the most important, so let's
decide upon how it looks like:

.file::bin/quick-install.sh
[source,sh,linenums]
----
#!/bin/sh

## include::quick-install/racket

## include::quick-install/ruby

## include::quick-install/asciidoctor

## include::quick-install/rackjure

## include::quick-install/ulquikit

----

Bourne shell is a horrible language, so even a simple check-and-make-decision
might end up look like:

[source,sh,linenums]
----
if [ `which some-exec >/dev/null 2>&1 && echo true || echo false` == "true" ]; then
   # Do-something
fi
----

Unfortunately, each part of this +quick-install.sh+ script requires that kind
of check.  Let's walk through them one by one.

==== Make sure Racket is installed

This task is simple done by checking whether +racket+ executable is found.
Note that it doesn't check Racket version.  The script fails if Racket is not
installed, thus the +exit 1+ command.

.code::quick-install/racket
[source,sh,linenums]
----
if [ `which racket >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Racket not found, please install it first."
    echo "   You might refer to your OS's package manager to install Racket,"
    echo "   or download it from: http://racket-lang.org/download/"
    echo "   Please MAKE SURE you have Racket 6+."
    echo "-> Installation aborted."
    exit 1
else
    echo "-> Found Racket.  MAKE SURE you have Racket 6+."
fi

----

==== Install Ruby 1.9 (using RVM) if necessary

.code::quick-install/ruby
[source,sh,linenums]
----
if [ `which ruby >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Ruby not found."
    echo "   You might refer to your OS's package manager to install Ruby."
    echo "   However, this script could install Ruby for you using RVM stable."
    echo "   Please refer to http://rvm.io for further information."

    echo -n "-> Would you like to install RVM stable single-user mode? [Y/n] "
    read DO_INSTALL_RVM

    if [ "$DO_INSTALL_RVM" == "" ] \
        || [ "$DO_INSTALL_RVM" == "y" ] \
        || [ "$DO_INSTALL_RVM" == "Y" ]; then
        echo "-> Installing Ruby 1.9 and RVM..."

        \curl -sSL https://get.rvm.io | bash -s stable
        [[ -f ~/.bashrc ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.bashrc)
        [[ -f ~/.zshrc  ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.zshrc)
        source $HOME/.rvm/scripts/rvm
        rvm install 1.9
        rvm use 1.9 --default
    else
        echo "-> Installation aborted."
        exit 1
    fi
else
    echo "-> Found Ruby.  MAKE SURE you have Ruby 1.9+."
fi
----

==== Install AsciiDoctor if necessary

.code::quick-install/asciidoctor
[source,sh,linenums]
----
if [ `which asciidoctor >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> AsciiDoctor found."
else
    echo "-> Installing AsciiDoctor..."
    gem install -V asciidoctor
fi

----

==== Install Rackjure if necessary

.code::quick-install/rackjure
[source,sh,linenums]
----
if [ `(raco pkg show | grep rackjure) >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> Rackjure found."
else
    echo "-> Installing Rackjure..."
    raco pkg install rackjure
fi

----

==== Install Ulquikit

NOTE: +DOWNLOAD_URL+ needs to change everytime there's new release.

.code::quick-install/ulquikit
[source,sh,linenums]
----
DOWNLOAD_URL=https://github.com/cmpitg/ulquikit/releases/download/v0.2.1/ulquikit-v0.2.1.zip

echo -n "-> Where would you like to install/update Ulquikit? (default: $HOME/) "
read ULQUIKIT_DEST
eval ULQUIKIT_DEST=$ULQUIKIT_DEST

if [ "$ULQUIKIT_DEST" == "" ]; then
    ULQUIKIT_DEST=$HOME/
fi

cd $ULQUIKIT_DEST

echo "-> Downloading latest version..."
wget -q "$DOWNLOAD_URL" -O ulquikit.zip

echo "-> Unpacking..."
unzip ulquikit.zip

echo "-> Removing zip file..."
rm -f ulquikit.zip

if [ `which ulqui >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo '-> Adding ulquikit/bin to your $PATH'
    [[ -f ~/.bashrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.bashrc)
    [[ -f ~/.zshrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.zshrc)

    echo "-> Done!  Enjoy your time with literate programming!"
else
    echo '-> Found ulqui command in your $PATH.'
fi

export PATH=$ULQUI_DEST/ulquikit/bin:$PATH

----

== Other meta-information

I figure out it's a good practice to good the application's meta-information
into one module.  Currently, it only contain version information and a way to
retrieve location of Ulquikit.

.file::ulquikit.rkt
[source,racket,linenums]
----
;; include::license-header

#lang racket

(require racket/path)

(provide +ulquikit-version+
         +ulquikit-location+)

;; include::ulquikit-version

;; include::ulquikit-location

----

Retrieving location of Ulquikit is simple and straightforward, we'll use
+syntax-source+ to do that:

.code::ulquikit-location
[source,racket,linenums]
----
(define-values (+ulquikit-location+ _ __)
  (split-path (syntax-source #'here)))

----

== License header

Since Ulquikit is distributed under the terms of GPLv3, the license header is
necessary.

.code::license-header
[source,lisp]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014-2015 Ha-Duong Nguyen <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----

== Extras

=== Command list

=== Story: How the Racket version of Ulquikit was actually developed

=== Emacs Lisp snippets to quickly compile snippets

[source,emacs-lisp,linenums]
----
(defun ~cl/next-snippet ()
  "Jumps to the next `eval'-able AsciiDoc snippet."
  (interactive)
  (cond ((re-search-forward "\\.\\(code\\|file\\).*\n\\[source,lisp" (point-max) t)
         (search-forward "----")
         (next-line)
         (beginning-of-line)
         (point))
        (t
         -1)))

(defun ~cl/compile-snippet ()
  "Compiles the current snippet with Common Lisp's Slime.  Note
that this function would not work reliably if the current point
is not inside a snippet."
  (interactive)
  (save-excursion
    (cond ((member major-mode '(lisp-mode common-lisp-mode))
           (beginning-of-buffer)
           (let ((start (point)))
             (end-of-buffer)
             (slime-compile-region start (point))))
          (t
           (re-search-backward "^----$")
           (next-line)
           (beginning-of-line)
           (let ((start (point)))
             (re-search-forward "^----$")
             (previous-line)
             (end-of-line)
             (slime-compile-region start (point)))))))


(global-set-key (kbd "<f5>") '~cl/next-snippet)
(global-set-key (kbd "<f6>") '~cl/compile-snippet)

;;; Or binding key with bind-key library
;; (bind-key "<f5>" '~cl/next-snippet)
;; (bind-key "<f6>" '~cl/compile-snippet)
----

=== Enhancing narrow-region functionality in Emacs
