= Ulquikit
:Author: Ha-Duong Nguyen (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Current version:

.code::ulquikit-version
[source,lisp,linenums]
----
(defvar *ulquikit-version* "2.0.0")
----

'''

Ulquikit was originally written in Racket using several bootstrap scripts
(also in Racket).  The current version is a complete rewrite in Common Lisp.

For building Ulquikit, the following dependencies are required:

* Ruby 2.1+ with
** http://asciidoctor.org[AsciiDoctor] - AsciiDoc renderer
** https://github.com/tmm1/pygments.rb[pygments.rb] - syntax highlighter
* An ANSI-compliant Common Lisp implementation, preferably
  http://www.sbcl.org[SBCL], with
** https://common-lisp.net/project/asdf[ASDF 3] - build tool
** https://www.quicklisp.org/beta/[Quicklisp] - library manager
** https://github.com/fukamachi/shelly[Shelly] - shelly-friendly interface

For installation of the above software, please consult their official
documentations.  On my setup, I use:

* SBCL 1.2+ with https://github.com/KeenS/CIM[CIM] (Common Lisp Implementation
  Manager)
* Ruby 2.1.3 with https://rvm.io[RVM] (Ruby Version Manager)

== Terminology

* A *code block* is an AsciiDoc code block.

* A *snippet* is a code block with Ulquikit-defined title and delimiter
  `----`.  By default, a code block title that starts `file::` and `code::`
  defines a _file snippet_ and _code snippet_, respectively:

** A *file snippet* is a snippet producing a source file.
** A *code snippet* is a snippet storing source code that can be included into
   other snippets.

* An *include directive* is a line of code that:

** belongs to a snippet
** has the format of `xx include::some-snippet-name` where `xx` are two
   identical characters denoting a comment.  Ulquikit can recogize the
   following comment types: `//`, `;;`, `##`, `--`, or C-stype `/*
   include::some-snippet-name */`, or XML-style `<!--
   include::some-snippet-name -->`.

== Interfaces

Before going into any detail, I would like to define the interfaces that
Ulquikit uses to interact with the outside world as a Common Lisp package.

.code::src/package.lisp
[source,lisp,linenums]
----
(defpackage #:ulquikit
  (:use :cl
        :alexandria
        :split-sequence
        :cl-ppcre
        :cl-cwd
        :trivial-utf-8
        :iterate)
  (:export #:generate-src
           #:generate-html

           #:snippet
           #:create-snippet
           #:extract-snippets-from-file
           #:sethash))

(in-package #:ulquikit)
----

Along with the main package comes the test one.  I decide to use
https://github.com/OdonataResearchLLC/lisp-unit[lisp-unit] since it has very
nice interface and helpful messages.

NOTE: Prior to `lisp-unit`, I have tried
https://github.com/capitaomorte/fiasco[Fiasco] with little success.  The
interface is nice inflexible.  There is no easy way to remove test or
redefining tests and test packages.

.code::src/package-test.lisp
[source,lisp,linenums]
----
(defpackage #:ulquikit-tests
  (:use :cl :ulquikit :cl-ppcre :lisp-unit :iterate :cl-fad))

(in-package #:ulquikit-tests)

;; Print failure details by default
(setf *print-failures* t)
----

== Extracting and including snippets

Ulquikit works by searching for all AsciiDoc documents inside
`<project-root>/src` directory, building a database of snippets, including
them into each other if necessary, then generating documentation and source
code.  Hence, the following functions are probably the most interesting ones:

* <<func/extract-snippets-from-file,`extract-snippets-from-file`>>, which
  helps extract snippets from a file
* <<func/include-snippet,`include-snippet`>>, which helps
  <<section/include-snippets,include snippets>> into each other

Let's talk about `extract-snippets-from-file` first:

=== Extracting snippets

First, we need to decide how snippets are stored.  This is very important as
every change made to this data structure would affect the code later on.

Each snippet is struct with following alist representation:

anchor:snippet-format[]

[source,lisp]
----
`((:type       . ,snippet-type)  <1>
  (:name       . ,snippet-name)  <2>
  (:linenum    . ,line-number)   <3>
  (:lines      . ,snippet-lines) <4>
  (:processed? . ,processed?))   <5>
----
<1> is either `:file` or `:code`
<2> is the name of the snippet; e.g. snippet with title `file::something` has `something` as its name.  Note that snippet name is _a string_.
<3> is the line number from the literate source code from where the snippet is extracted
<4> is the content of the snippet as a list of lines, necessary for performance purpose
<5> determines whether this snippet has been processed? to include others, when created for the first time, `'processed?` is always `#f`.  It's only changed after the snippet has been passed through <<include-snippet,+include-snippet+>>

Thus, a struct representation of a snippet is defined as followed:

.code::define-snippet
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defstruct snippet
  (type :code     :type keyword)
  (name ""        :type string)
  (linenum 0      :type integer)
  (lines (list)   :type list)
  (processed? nil :type boolean))
----

IMPORTANT: Snippets should never be created by directly by using
`make-snippet`.  They should be created with
<<func/create-snippet,`create-snippet`>>.

Since a snippet stores a list of lines as its content, it'd be convenient to
have a helper that joins those lines into a complete string:

.code::get-snippet-content
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun get-snippet-content (snippet)
  "Returns the content of a snippet, i.e. all of its lines are joined by
newline characters."
  (declare (type snippet snippet))
  (format nil "~{~A~^~%~}" (snippet-lines snippet)))
----

`create-snippet` is simply implemented as followed:

anchor:func/create-snippet[]
.code::create-snippet
[source,lisp,linenums]
----
;; include::get-snippet-content

(in-package #:ulquikit)

(defun create-snippet (&key type name linenum lines (processed? nil))
  "Helper to create snippet."
  (let ((type (->keyword type))
        (name (->string name))
        (lines (if (stringp lines)
                   (split-sequence #\Newline lines)
                 lines)))
    (the snippet (make-snippet :type type
                               :name name
                               :linenum linenum
                               :lines lines
                               :processed? processed?))))

(in-package #:ulquikit-tests)

(define-test test-snippet-creation
  (assert-equalp #S(snippet
                    :type :file
                    :name "hello-world"
                    :linenum 10
                    :lines ("Hmm")
                    :processed? nil)
                 (create-snippet :type :file
                                 :name 'hello-world
                                 :linenum 10
                                 :lines '("Hmm")))
  (assert-equalp #S(snippet
                    :type :string
                    :name "string"
                    :linenum 100
                    :lines ("string")
                    :processed? t)
                 (create-snippet :type "string"
                                 :name "string"
                                 :linenum 100
                                 :lines "string"
                                 :processed? t)))

;;; (run-tests)

(in-package #:ulquikit)

;;; Utils

(defun ->keyword (val)
  "Converts a symbol or string into keyword."
  (declare (type (or keyword symbol string) val))
  (the keyword (etypecase val
                 (keyword val)
                 (symbol (intern (string-upcase (symbol-name val)) 'keyword))
                 (string (intern (string-upcase val) 'keyword)))))

(defun ->string (val)
  "Converts a symbol or keyword into string."
  (declare (type (or keyword symbol string) val))
  (the string (etypecase val
                (string val)
                ((or symbol keyword) (string-downcase (symbol-name val))))))

----

Now the helper `create-snippet` is ready.  Let's move on to
`extract-snippets-from-file`.

`extract-snippets-from-file` needs to determine whether _a line in a code
block_ belongs to a _code snippet_, or _file snippet_, or none of those; then
extracts the content of the code block and store it if necessary.  The 3 types
of code block that we deal with are as followed:

* A _code snippet_ has the following format:
+
[listing]
..........
.code::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.code::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........


* A _file snippet_ shares the same structure as a _code snippet_:
+
[listing]
..........
.file::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........
+
or
+
[listing]
..........
[source]                        <2>
.file::title-of-the-code-block  <1>
----                            <3>
Content of the code block
----                            <4>
..........


* A non-snippet code block is any block without +code::...+ or +file::...+ as
  its title:
+
[listing]
..........
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>

....                            <3>
This is a literal block
....                            <4>
..........

<1> block title
<2> block type
<3> block delimiter
<4> block delimiter

As we can clearly see from the 3 examples, _code snippets_ and _file snippets_
could be determined by checking 2^nd^ previous line from block delimiter to
see if it starts with `.file::` or `.code::`.  Everything between the 2
delimiters is stored as the content of the snippet.

Before diving into `extract-snippets-from-file`, let us define a data
structure for storing all snippets:

[source,lisp,linenums]
----
(in-package #:ulquikit)

(defstruct snippets
  (file (make-hash-table :test #'equal) :type hash-table)
  (code (make-hash-table :test #'equal) :type hash-table))
----

We have the following algorithm for `extract-snippets-from-file`:

* Read the content of a file;

* Break the content into lines, preserving line numbers;

* For each line:

** If we're already inside a snippet:

*** Complete a snippet and add it to snippet list if current line is a block
    delimiter (i.e. `----`)

*** Add current line to the current snippet's content if current line is not a
    block delimiter

** If we're outside a snippet, we only care if current line is a block
   delimiter (i.e. `----`):

*** If this block has a title that marks the beginning of a snippet (i.e. the
    2^nd^ previous line starts with `.file::` or `.code::`), extract snippet
    name and add a new snippet.  Otherwise

*** If this block does not mark the beginning of a snippet, ignore it.

anchor:func/extract-snippets-from-file[]
.code::extract-snippets-from-file
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun extract-snippets-from-file (path)
  "Extracts snippets from a file and return a `snippets' struct."
  (declare (type (or string pathname) path))
  (let* ((text (string-trim '(#\Space #\Newline #\e #\t #\m) (read-file path)))
         (lines (split-sequence #\Newline text))

         (snippets (make-snippets))

         (prev-prev-line "")
         (prev-line      "")
         (linenum        0)             ; current line number
         (inside?        nil)           ; current inside a snippet?

         (s/type       :code)
         (s/lines/rev  (list))
         (s/name       "")
         (s/linenum    0))
    (dolist (line lines)
      (incf linenum)

      ;; (format t "~A |> ~A~%" linenum line)
      ;; (format t "   |> block? ~A~%" (block-delimiter? line))

      (cond ((and inside? (not (block-delimiter? line)))

             (push line s/lines/rev))

            ((and inside? (block-delimiter? line))

             ;; Close the current snippet
             (setf inside?  nil
                   snippets (collect-snippet snippets
                                             (create-snippet
                                              :type s/type
                                              :name s/name
                                              :lines (nreverse s/lines/rev)
                                              :linenum s/linenum))))

            ((and (not inside?) (block-delimiter? line))
             ;; (format t "  found snippet > num: ~A~%" linenum)

             (when-let (title (cond ((block-title? prev-line) prev-line)
                                    ((block-title? prev-prev-line) prev-prev-line)
                                    (t nil)))
               (multiple-value-bind (type name) (parse-snippet-title title)
                 (setf inside?     t
                       s/type      type
                       s/name      name
                       s/lines/rev (list)
                       s/linenum   (1- linenum))))))

      ;; Update previous lines
      (unless (zerop (length (string-trim '(#\Space #\Newline #\e #\t #\m) line)))
        (setf prev-prev-line prev-line
              prev-line      line)))

    ;; (list linenum (length lines) snippets)
    snippets))

;; (extract-snippets-from-file "/m/src/ulquikit/src/Ulquikit.adoc")
;; (time (extract-snippets-from-file "/m/src/ulquikit/src/Ulquikit.adoc"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun read-file (path)
  "Reads a file as UTF-8 encoded string."
  (declare ((or string pathname) path))
  (the string (with-open-file (in path :element-type '(unsigned-byte 8))
                (read-utf-8-string in :stop-at-eof t))))

(in-package #:ulquikit)

(defun block-delimiter? (str)
  "Determines if a string is a block delimiter.  TODO: Make this extensible."
  (scan "^----( *)$" str))

(in-package #:ulquikit-tests)

(define-test test-block-delimiter
  (import 'ulquikit::block-delimiter?)
  (assert-true (block-delimiter? "----"))
  (assert-true (not (block-delimiter? " ----")))
  (assert-true (block-delimiter? "---- "))
  (assert-true (block-delimiter? "----  "))
  (assert-true (not (block-delimiter? "----a"))))

;; (run-tests)

(in-package #:ulquikit)

(defun block-title? (str)
  "Determines if a string is a block title.  TODO: Make this extensible."
  (scan "^\\.(file|code)::" str))

(in-package #:ulquikit-tests)

(define-test test-block-title
  (import 'ulquikit::block-title?)
  (assert-true (block-title? ".file::something"))
  (assert-true (block-title? ".file::something else"))
  (assert-true (block-title? ".file::"))
  (assert-true (null (block-title? ".file:something"))))

;; (run-tests)

(in-package #:ulquikit)

(defun parse-snippet-title (title)
  "Parses a snippet title and returns `(values <snippet-type>
<snippet-name>)'."
  (declare (string title))
  (multiple-value-bind (_ res) (scan-to-strings "\.(file|code)::(.*)" title)
    (declare (ignore _))
    (values (the keyword (->keyword (aref res 0)))
            (the string  (aref res 1)))))

(in-package #:ulquikit-tests)

(define-test test-parse-snippet-title
  (import 'ulquikit::parse-snippet-title)
  (dolist (el '((".file::"    . (:file ""))
                (".code::"    . (:code ""))
                (".file::abc" . (:file "abc"))
                (".code::a b" . (:code "a b"))))
    (let ((title    (first el))
          (expected (rest  el)))
      (multiple-value-bind (type name) (parse-snippet-title title)
        (assert-equal expected (list type name))))))

;; (run-tests)

(in-package #:ulquikit)

(defun collect-snippet (snippets snippet)
  "Collects `snippet' into the list of snippets."
  (declare (snippets snippets)
           (snippet  snippet))
  (let* ((type (snippet-type snippet))
         (name (snippet-name snippet))
         (current-file (snippets-file snippets))
         (current-code (snippets-code snippets))
         (file (case type
                 (:file     (setf (gethash name current-file) snippet)
                            current-file)
                 (otherwise current-file)))
         (code (case type
                 (:code     (setf (gethash name current-code) snippet)
                            current-code)
                 (otherwise current-code))))
    (the snippets (make-snippets :file file
                                 :code code))))

(in-package #:ulquikit-tests)

(define-test test-collect-snippets
  (import 'ulquikit::snippets)
  (import 'ulquikit::make-snippets)
  (import 'ulquikit::collect-snippet)
  (assert-equalp (collect-snippet (make-snippets)
                                  (create-snippet :type :file
                                                  :name :hello
                                                  :linenum 10
                                                  :lines '("Something")))
                 (make-snippets
                  :file (alexandria:alist-hash-table `(("hello" . ,#s(snippet
                                                                      :type :file
                                                                      :name "hello"
                                                                      :linenum 10
                                                                      :lines ("Something")
                                                                      :processed? nil)))
                                                     :test #'equal)
                  :code (make-hash-table :test #'equal)))

  (assert-equalp (collect-snippet
                  (make-snippets
                   :file (alexandria:alist-hash-table `(("hello" . ,#s(snippet
                                                                       :type :file
                                                                       :name "hello"
                                                                       :linenum 10
                                                                       :lines ("Something")
                                                                       :processed? nil)))
                                                      :test #'equal)
                   :code (make-hash-table :test #'equal))
                  (create-snippet :type 'code
                                  :name 'say-something
                                  :linenum 100
                                  :lines '("Something else")))
                 (make-snippets :file (alexandria:alist-hash-table
                                       `(("hello" . ,#s(snippet
                                                        :type :file
                                                        :name "hello"
                                                        :linenum 10
                                                        :lines ("Something")
                                                        :processed? nil)))
                                       :test #'equal)
                                :code (alexandria:alist-hash-table
                                       `(("say-something" . #s(snippet
                                                               :type :code
                                                               :name "say-something"
                                                               :linenum 100
                                                               :lines ("Something else")
                                                               :processed? nil)))
                                       :test #'equal))))

;; (run-tests '(test-collect-snippets))

----

As a result, `extract-snippets`, which extracts snippets from all AsciiDoc
documents in a directory recursively, makes use of
`extract-snippets-from-file`.  `extract-snippets` takes a path and returns a
`snippets` struct.

.code::extract-snippets
[source,lisp,linenums]
----
;; include::extract-snippets-from-file

(in-package #:ulquikit)

(defun extract-snippets (path)
  "Extracts all snippets from all AsciiDoc directory in `path'.  The AsciiDoc
files are found recursively."
  (declare ((or string pathname) path))
  (reduce #'(lambda (current-snippets adoc-file)
              (declare (type snippets current-snippets)
                       (type (or string pathname) adoc-file))
              (let ((new-snippets (extract-snippets-from-file adoc-file)))
                ;; Merging 2 snippets
                (maphash #'(lambda (key value)
                             (setf (gethash key
                                            (snippets-file current-snippets))
                                   value))
                         (snippets-file new-snippets))
                (maphash #'(lambda (key value)
                             (setf (gethash key
                                            (snippets-code current-snippets))
                                   value))
                         (snippets-code new-snippets))
                current-snippets))
          (get-all-adocs path)
          :initial-value (make-snippets)))

(in-package #:ulquikit-tests)

(define-test test-extract-snippets
  (import 'ulquikit::extract-snippets)
  (import 'ulquikit::snippets-file)
  (import 'ulquikit::snippets-code)
  (let* ((test-dir (merge-pathnames
                    "ulquikit/test-extract-snippets/"
                    (cl-fad:pathname-as-directory (uiop:getenv "TMPDIR"))))

         (content `(("Main.adoc" . "= A sample program

This program consists of several snippets and a hello

== Main program

The main program includes function `say-hello` from `lib/Say-Hello.adoc` and
function `say-world` from `lib/Say-World.adoc` and calls them.

.file::/tmp/main.lisp
\----
;; include::say-hello

;; include::say-world

\(say-hello\)
\(say-world\)

\----
")
                    ("License" . "Do what you want to do with it!")
                    ("lib/Say-Hello.adoc" . "What do you actually expect in this
file?  Two snippets, one of which doesn't get captured.

.code::say-hello
[source,lisp,linenums]
\----
\(defun say-hello \(\)
  \(format t \"Hello \"\)\)
\----

The following snippet doesn't get captured as it has no title:

[source,lisp,linenums]
\----
\(defun throw-away \(\)
  \(error \"If you see me, there is at least one error happened!\"\)\)
\----
")
                    ("lib/Say-World.adoc" . "Another way to define code block title with AsciiDoc:

[source,lisp,linenums]
.code::say-world
\----
\(defun say-world \(\)
  \(format t \"world!~%\"\)\)
\----
")))
         (files (mapcar #'(lambda (content-pair)
                            (cons (merge-pathnames (car content-pair) test-dir)
                                  (cdr content-pair)))
                        content)))
    (cl-fad:delete-directory-and-files test-dir :if-does-not-exist :ignore)

    (dolist (path+content files)
      (let ((path    (car path+content))
            (content (cdr path+content)))
        (ensure-directories-exist path)
        (with-open-file (out path :direction :output)
          (princ content out))))

    (let* ((snippets (extract-snippets test-dir))
           (file-snippets (snippets-file snippets))
           (code-snippets (snippets-code snippets)))
      (assert-equal 1 (hash-table-count file-snippets))
      (assert-equal 2 (hash-table-count code-snippets))

      (assert-equal ";; include::say-hello

;; include::say-world

\(say-hello\)
\(say-world\)
"
                    (snippet->string (gethash "/tmp/main.lisp" file-snippets)))
      (assert-equal "\(defun say-hello \(\)
  \(format t \"Hello \"\)\)"
                    (snippet->string (gethash "say-hello" code-snippets)))
      (assert-equal "\(defun say-world \(\)
  \(format t \"world!~%\"\)\)"
                    (snippet->string (gethash "say-world" code-snippets))))))

;;; (run-tests '(test-extract-snippets))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun snippet->string (snippet)
  "Returns the string representation of a snippet."
  (declare (snippet snippet))
  (the string (format nil "~{~A~^~%~}" (snippet-lines snippet))))

;;; (snippet->string (make-snippet))

(in-package #:ulquikit-tests)

(define-test test-snippet->string
  (import 'ulquikit::snippet->string)
  (import 'ulquikit::make-snippet)
  (assert-equal "" (snippet->string (make-snippet)))
  (assert-equal "aoeu" (snippet->string (make-snippet :lines '("aoeu"))))
  (assert-equal "aoeu
ueoa"
                (snippet->string (make-snippet :lines '("aoeu" "ueoa")))))

;;; (run-tests '(test-snippet->string))

(in-package #:ulquikit)

(defun get-all-adocs (path)
  "Retrieves all AsciiDoc files in `path' recursively.  TODO: Make this
extensible."
  (declare ((or string pathname) path))
  ;; (format t "Getting all adocs from path: ~A~%" path)
  (let ((adocs (list)))
    (cl-fad:walk-directory path #'(lambda (file)
                                    (push file adocs))
                           :directories nil
                           :if-does-not-exist :ignore
                           :test #'(lambda (file)
                                     (scan "\\.adoc$" (namestring file)))
                           :follow-symlinks t)
    adocs))

(in-package #:ulquikit-tests)

(define-test test-get-all-adocs
  (import 'ulquikit::get-all-adocs)
  (let* ((files '("a.adoc"
                  "b.adoc"
                  "c.md"
                  "e.adoc"
                  "hello/a.adoc"
                  "hello/b.html"
                  "hello/world/hola.adoc"
                  "hello/world/mundo.adoc"))
         (temppath (merge-pathnames "ulquikit/test-get-all-adocs/"
                                    (pathname (cl-fad:pathname-as-directory
                                               (uiop:getenv "TMPDIR")))))
         (expected (iterate
                     (for path in files)
                     (when (scan "\\.adoc$" path)
                       (collect (merge-pathnames path temppath))))))
    ;; Setup
    (cl-fad:delete-directory-and-files temppath
                                       :if-does-not-exist :ignore)
    (dolist (path files)
      (let ((file (merge-pathnames path temppath)))
        (ensure-directories-exist (path:dirname file))
        (with-open-file (out file :direction :output
                             :if-exists :supersede)
          (princ "Hello world" out))))

    (let ((adocs (get-all-adocs temppath)))
      (assert-equalp (sort expected #'(lambda (path1 path2)
                                        (string< (namestring path1)
                                                 (namestring path2))))
                     (sort adocs #'(lambda (path1 path2)
                                     (string< (namestring path1)
                                              (namestring path2))))))

    ;; Tear down
    (cl-fad:delete-directory-and-files temppath
                                       :if-does-not-exist :ignore)))

----

After `extract-snippets`, the next important function is `include-snippet`,
used to include snippets into each other.  Let's see how we could
implement it.

anchor:section/include-snippets[]

=== Including snippets into each other

`include-snippet!` takes 2 arguments:
* the current list of snippets,
* a cons of format `(type . name)` representing the snippet being processed,
  this snippet must be a part of the current list of snippets,

This function returns the new list of snippets that have been processed.

`include-snippet!` works by browsing the target snippet's content, one line at
a time, then replacing lines with `include::` directives with the
corresponding __code snippet__s in `snippets`.  If no snippet is found, the
line is left as-is.

Note that:

* To prevent unnecessary copy, this function has side effects for all of its
  arguments, hence its name is suffixed with a bang (`!`).

* If snippet A includes snippet B, and snippet B includes snippets C and D, so
  the best scenario is to include C and D into B while we're actually
  processing A.  I.e. `include-snippet` should be recursive to accumulate the
  results.

WARNING: The result of circular dependency, e.g. snippet A includes itself, is
*undefined*.  Make sure your snippets are well managed.

As a result, we have this implementation:

anchor:func/include-snippet[]

.code::include-snippet
[source,lisp,linenums]
----
(in-package #:ulquikit)

(defun include-snippet! (snippets type+name)
  "Processed target snippet by replacing all of its \"include\" directives
with the corresponding snippets found in `snippets'.  If the target snippet
introduces circular dependency, the result is undefined.  This function
modifies `snippets' in-place and returns it after processing."
  (declare (cons type+name) (snippets snippets))

  ;; (format t "→ including snippet ~A~%" type+name)

  ;; Ignore of the target snippet doesn't exist in the list of snippets
  (when (snippet-exists? type+name snippets)
    (let* ((target/type (car type+name))
           (target/name (cdr type+name))
           (target      (snippets/get-snippet snippets
                                              :type target/type
                                              :name target/name))
           (lines       (snippet-lines target))
           (lines-final (list)))
      ;; Also, we ignore if this snippet has already been processed
      (unless (snippet-processed? target)
        ;; Consider this snippet processed
        (setf (snippet-processed? target) t)

        ;; Now, recollect lines
        (dolist (line lines)
          ;; (format t "  Processing ~A~%" line)
          (if (include-directive? line)
              (let* ((includee-name (parse-include-directive line))
                     (includee      (snippets/get-snippet snippets
                                                          :type :code
                                                          :name includee-name)))
                (cond ((null includee)
                       ;; No such snippet to include
                       (push line lines-final))

                      ((snippet-processed? includee)
                       (push (join-lines (snippet-lines includee))
                             lines-final))

                      ((not (snippet-exists? includee snippets))
                       (push line lines-final))

                      (t
                       (setf snippets (include-snippet!
                                       snippets
                                       `(:code . ,includee-name)))
                       (push (join-lines (snippet-lines includee)) 
                             lines-final))))
            (push line lines-final)))

        ;; (format t "Snippet: ~A; result: ~A~%"
        ;;         (cdr type+name)
        ;;         (join-lines (reverse (copy-list lines-final))))

        ;; Then, collect result
        (setf (snippet-lines target)
              (list (join-lines (nreverse lines-final)))))))
  snippets)

(in-package #:ulquikit-tests)

;;; (run-tests '(test-include-snippet))

(import 'ulquikit::make-snippet)
(import 'ulquikit::snippet-name)
(import 'ulquikit::snippet-lines)
(import 'ulquikit::snippet-processed?)
(import 'ulquikit::snippets-file)
(import 'ulquikit::snippets-code)
(import 'ulquikit::include-snippet!)
(define-test test-include-snippet
  (let* ((snp/file (make-snippet :name "/tmp/tmp.lisp"
                                 :type :file
                                 :lines '(";; include::A"
                                          ";; The end")
                                 :linenum 10))
         (snp/code/A (make-snippet :name "A"
                                   :type :code
                                   :lines '("World"
                                            ";; include::B"
                                            ";; include::D")
                                   :linenum 20))
         (snp/code/B (make-snippet :name "B"
                                   :type :code
                                   :lines '("Hello")
                                   :linenum 30))
         (snp/code/C (make-snippet :name "C"
                                   :type :code
                                   :lines '("Not processed")
                                   :linenum 15))
         ;; Circular dependency
         (snp/code/D (make-snippet :name "D"
                                   :type :code
                                   :lines '(";; include A")
                                   :linenum 100))

         (snippets (let* ((res (make-snippets))
                          (snippets/file (snippets-file res))
                          (snippets/code (snippets-code res)))
                     (setf (gethash "/tmp/tmp.lisp" snippets/file) snp/file
                           (gethash "A" snippets/code) snp/code/A
                           (gethash "B" snippets/code) snp/code/B
                           (gethash "C" snippets/code) snp/code/C
                           (gethash "D" snippets/code) snp/code/D)
                     ;; Don't add D right away
                     res)))
    (setf snippets (include-snippet! snippets `(:code . "A")))
    (assert-true t)
    (assert-true (snippet-processed? snp/code/A))
    (assert-true (snippet-processed? snp/code/B))
    (assert-true (snippet-processed? snp/code/D))
    (assert-false (snippet-processed? snp/code/C))
    (assert-false (snippet-processed? snp/file))
    (assert-true (scan "^World\\nHello\\n"
                       (nth 0 (snippet-lines snp/code/A))))

    (setf snippets (include-snippet! snippets `(:file . "/tmp/tmp.lisp")))
    (let ((content (nth 0 (snippet-lines snp/file))))
      (assert-true (snippet-processed? snp/file))
      (assert-true (scan "^World\\nHello\\n" content))
      (assert-true (scan ";; The end$" content)))))

;;; (run-tests '(test-include-snippet))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulquikit)

(defun snippet-exists? (snippet snippets)
  "Determines if the corresponding snippet is in `snippets'."
  (declare ((or snippet string cons) snippet)
           (snippets snippets))
  (typecase snippet
    ((or cons snippet)
     (let ((name (typecase snippet
                   (cons    (cdr snippet))
                   (snippet (snippet-name snippet))))
           (type (typecase snippet
                   (cons    (car snippet))
                   (snippet (snippet-type snippet)))))
       (case type
         (:code (not (null (gethash name (snippets-code snippets)))))
         (:file (not (null (gethash name (snippets-file snippets))))))))
    (string
     (or (not (null (gethash snippet (snippets-code snippets))))
         (not (null (gethash snippet (snippets-file snippets))))))))

(in-package #:ulquikit-tests)

(import 'ulquikit::snippet-exists?)
(define-test test-snippet-exists?
  (let* ((code/a (make-snippet :name "a" :type :code))
         (code/b (make-snippet :name "b" :type :code))
         (file/a (make-snippet :name "a" :type :file))
         (file/b (make-snippet :name "b" :type :file))
         (snippets (let ((res (make-snippets)))
                     (setf (gethash "a" (snippets-code res)) code/a)
                     (setf (gethash "a" (snippets-file res)) file/a)
                     res)))
    (assert-eq t   (snippet-exists? code/a snippets))
    (assert-eq t   (snippet-exists? file/a snippets))
    (assert-eq t   (snippet-exists? "a"    snippets))
    (assert-eq t   (snippet-exists? `(:code . "a") snippets))
    (assert-eq t   (snippet-exists? `(:file . "a") snippets))
    (assert-eq nil (snippet-exists? `(:code . "b") snippets))
    (assert-eq nil (snippet-exists? code/b snippets))
    (assert-eq nil (snippet-exists? file/b snippets))
    (assert-eq nil (snippet-exists? "b"    snippets))))

;;; (run-tests '(test-snippet-exists?))

(in-package #:ulquikit)

(defmacro sethash (obj hash value)
  "Helper macro, used to directly set hash value."
  `(setf (gethash ,obj ,hash) ,value))

(in-package #:ulquikit-tests)

(define-test test-macro-sethash
  (let ((hash (make-hash-table)))
    (sethash :first hash "hello")
    (sethash :second hash "world")
    (assert-equal "hello" (gethash :first hash))
    (assert-equal "world" (gethash :second hash))))

;;; (run-tests '(test-macro-sethash))

(in-package #:ulquikit)

(defun include-directive? (line)
  "Determines of the corresponding line is a include directive.  TODO: Make this extensible."
  (declare (string line))
  (let ((line (string-trim '(#\Space #\e #\t #\m) line)))
    (not (null (or (scan "^[#;/-]{2} include::.*" line)
                   (scan "^<!-- include::.* -->" line)
                   (scan "^/\\* include::.* \\*/" line))))))

(in-package #:ulquikit-test)

(import 'ulquikit::include-directive?)
(define-test test-include-directive?
  (assert-eq t   (include-directive? "  ;; include::"))
  (assert-eq t   (include-directive? ";; include::"))
  (assert-eq nil (include-directive? "a;; include::"))
  (assert-eq t   (include-directive? ";; include::something"))
  (assert-eq t   (include-directive? "## include::something"))
  (assert-eq t   (include-directive? "// include::something"))
  (assert-eq t   (include-directive? "/* include::something */"))
  (assert-eq t   (include-directive? "<!-- include::something -->"))
  (assert-eq nil (include-directive? "a <!-- include::something -->")))

;;; (run-tests '(test-include-directive?))

(in-package #:ulquikit)

(defun join-lines (lines)
  "Joins a list of strings with newline as separator."
  (declare (list lines))
  (format nil "~{~A~^~%~}" lines))

(in-package #:ulquikit-tests)

(import 'ulquikit::join-lines)
(define-test test-join-lines
  (assert-equal "" (join-lines '()))
  (assert-equal "a" (join-lines '("a")))
  (assert-equal (format nil "a~%b") (join-lines '("a" "b")))
  (assert-equal (format nil "a~%b~%") (join-lines '("a" "b" ""))))

;;; (run-tests '(test-join-lines))

(in-package #:ulquikit)

(defun parse-include-directive (str)
  "Parses and extracts snippet name from an include directive.  See its tests
for detailed information on input/output format.  TODO: make this extensible."
  (declare (string str))
  (if (include-directive? str)
      (let ((input (cond ((and (scan " -->$" str) (scan "^<!-- " str))
                          (subseq str 0 (- (length str) (length " -->"))))
                         ((and (scan " \\*/$" str) (scan "^/\\* " str))
                          (subseq str 0 (- (length str) (length " */"))))
                         (t
                          str))))
        (multiple-value-bind (_ name/array)
            (scan-to-strings "include::(.*)$" input)
          (declare (ignore _))
          (elt name/array 0)))
    ""))

(in-package #:ulquikit-tests)

(import 'ulquikit::parse-include-directive)
(define-test test-include-directive
  (assert-equal "" (parse-include-directive "  ;; include::"))
  (assert-equal "" (parse-include-directive ";; include::"))
  (assert-equal "" (parse-include-directive
                    "a <!-- include::something -->"))
  (assert-equal "something" (parse-include-directive
                             ";; include::something"))
  (assert-equal "something" (parse-include-directive
                             "## include::something"))
  (assert-equal "something" (parse-include-directive
                             "// include::something"))
  (assert-equal "something" (parse-include-directive
                             "/* include::something */"))
  (assert-equal "something" (parse-include-directive
                             "<!-- include::something -->")))

;;; (run-tests '(test-include-directive))

(in-package #:ulquikit)

(defun snippets/get-snippet (snippets &key
                                        (type :code)
                                        name)
  "Helper to quickly retrieve a snippet from a `snippets' struct."
  (declare (snippets snippets)
           (keyword  type)
           (string   name))
  (let ((hash (case type
                (:code (snippets-code snippets))
                (:file (snippets-file snippets))
                (otherwise (make-hash-table)))))
    (gethash name hash)))

(in-package #:ulquikit-tests)

(import 'ulquikit::snippets/get-snippet)
(define-test test-snippets/get-snippet
  (let* ((snp/code/a (make-snippet :type :code :name "a"))
         (snp/code/b (make-snippet :type :code :name "b"))
         (snp/file/c (make-snippet :type :file :name "c.lisp"))
         (snippets (let ((res (make-snippets)))
                     (sethash "a" (snippets-code res) snp/code/a)
                     (sethash "b" (snippets-code res) snp/code/b)
                     (sethash "c" (snippets-file res) snp/file/c)
                     res)))
    (assert-equal snp/code/a (snippets/get-snippet snippets
                                                   :type :code
                                                   :name "a"))
    (assert-equal snp/code/b (snippets/get-snippet snippets
                                                   :type :code
                                                   :name "b"))
    (assert-equal snp/file/c (snippets/get-snippet snippets
                                                   :type :file
                                                   :name "c"))))

;;; (run-tests '(test-snippets/get-snippet))
----

And that concludes the most important functions of Ulquikit.  Those are used
to implement the higher-level <<section/generate-source,`generate-src`>> right
below.

anchor:command/generate-src[]

=== Generating source code

`generate-src` generates source code from the `from` argument, which denotes a
directory containing literate source files, to the `to` argument, which
denotes a directory containing the generated source code.  The literate source
files are retrieved recursively.

.code::generate-src
[source,lisp,linenums]
----
(defun generate-src (&key (from "src")
                       (to "generated-src"))
  "Generates source code from all literate source files in `from' to directory
`to'.  `from' is either a directory or a single literate source file."
  (declare ((or string pathname) from to))
  (let* ((from     (uiop:merge-pathnames* from (uiop:getcwd)))
         (to       (uiop:merge-pathnames* to (uiop:getcwd)))
         (snippets (if (file? from)
                       (extract-snippets-from-file from)
                     (extract-snippets from))))
    (write-src-files (include-file-snippets snippets) to)))

----

The ultimate goal of generating source code is to produce files, so we only
need to include other snippets into file snippets.  +include-file-snippets+
does exactly that.  This function takes a hash of snippets as a result of the
call to +extract-snippets+ and returns a hash of snippets with all file
snippets <<section/include-snippets,included>>.  Let's combine the implement
of +include-file-snippets+ and +generate-src-files+ to make a complete set of
helpers for +generate-src+.

.code::generate-snippets-helpers
[source,racket,linenums]
----
;; lang racket

(define (include-file-snippets snippets)
  (let ([boxed (box snippets)]
        [file-snippets/names (hash-keys (get-file-snippets snippets))])
    (for ([target-name file-snippets/names])
      (let* ([target (~> snippets 'file target-name)])
        (include-snippet boxed target {})))
    (unbox boxed)))

(define (generate-src-files snippets to)
  (for ([(name snippet) (get-file-snippets snippets)])
    (let* ([path    (get-path to name)]
           [content (get-snippet-content snippet)])
      (create-dir (path->directory path))
      (displayln (~a "-> Writing " path))
      (display-to-file content path #:exists 'truncate/replace))))

(define get-file-snippets #λ(% 'file #:else {}))

(define get-code-snippets #λ(% 'code #:else {}))

----

And of course, we need to define help string for +generate-src+:

.file::commands/generate-src.help.txt
[source,text,linenums]
----
ulqui generate-src [--from from] [--to to]

Generate source code from literate documents.

  --from   either path to a directory literate documents are stored, or path
           to one literate document; default: "src"
  --to     directory where source code are generated, default: "generated-src"

Examples

Generate source code from src/ to generated-src/
  ulqui generate-src

or explitcitly
  ulqui generate-src --from src/ --to generated-src/

Generate source code from ../literate-source/ to ../source/
  ulqui generate-src --from ../literate-source/ --to ../source/

----

Once all functions are ready, let's put them together into a command to
generate source code.

.file::commands/generate-src.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")

(require "../utils/utils.rkt")
(require "../utils/path.rkt")
(require "../utils/string.rkt")

(provide run)

(module+ test
  (require rackunit))

;; include::generate-src

(define (run #:from [from "src"]
             #:to   [to   "generated-src"])
  (display-command "Generating source")
  (generate-src #:from from
                #:to   to))

----

That's how +generate-src+ should be done.  It's time to generalize this
structure for defining other commands as well.

== Anatomy of a Ulquikit command

Ulquikit commands are actually a Racket modules, residing in +commands/+.  The
name of the module (without +.rkt+ extension of course) is the actual command.
E.g. +commands/generate-src.rkt+ implements +generate-src+ command.

As a rule of thumb, each command has to provide at least 2 functions: +run+
and +help+:

* Command line arguments are parsed and passed through +run+ function.  Named
  arguments are automatically converted to either boolean or number and passed
  as Racket keywords.
+
E.g.

** +ulqui generate-src+ calls ++commands/generate-src++'s +(run)+.
** +ulqui generate-src some-file+ calls ++commands/generate-src++'s +(run "some-file")+.
** +ulqui generate-src --from file1 --to file2+ calls
   ++commands/generate-src++'s +(run #:from "file1" #:to "file2")+.

* When +ulqui help command-name+ or +ulqui command-name --help+ is invoked,
  the +help+ function that belongs to +commands/command-name.rkt+ module is
  called.  The same effect could be achieved by calling +(run #:help #t)+.
  This the +help+ function takes no arguments and returns a string that would
  be displayed as help.

* Usually, in a typical program, help strings are hardcoded into the source
  code, which makes the maintenance of help strings harder that necessary, not
  to mention the code looks really ugly.  Ulquikit defines a convention for
  writing and maintaining helps more effectively: command +do-something+ has
  its help stored in +commands/do-something.help.txt+.  See the implementation
  of <<command/generate-src,+generate-src+>> for more details on
  <<help/generate-src,how help string>> is stored.

* All commands must import +command-core.rkt+ (relative to command directory:
  +../command-core.rkt+).

With all that has been said, let's move on to the function which is used to
parse command line arguments.

=== Parsing command line arguments +parse-command-args+

This function takes all arguments passed to the command line as a list of
string and returns a map of following format:

[source,racket]
----
{'arguments list-of-arguments  <1>
 'options   hash-of-options}   <2>
----
<1> main arguments collected as a list, with the same order as they are at the
command line
<2> options are collected a hash; options that have no values are set to +#t+

[[func/parse-command-args]]
.code::parse-command-args
[source,racket,linenums]
----
;; include::parse-command-args-helpers

(define (parse-command-args args)
  (let ([arguments (takef args is-argument?)]
        [rest-args (dropf args is-argument?)])
    (let parse-options ([rest-args  rest-args]
                        [options    {}])
      (if (empty? rest-args)
          {'arguments arguments
           'options   options}
          (let* ([option-name   (first rest-args)]
                 [option-values (takef (drop rest-args 1) is-argument?)]
                 [rest-args     (dropf (rest rest-args)   is-argument?)]

                 [option-values/converted (map try-convert-value option-values)]

                 [name   (option->keyword option-name)]
                 [values (cond [(zero? (length option-values/converted))
                                #t]
                               [(= (length option-values/converted) 1)
                                (first option-values/converted)]
                               [else
                                option-values/converted])])
            (parse-options rest-args
                           (options name values)))))))

(module+ test
  (check-equal? (parse-command-args '())
                {'arguments '()
                 'options   {}})

  (check-equal? (parse-command-args '("hello-world"))
                {'arguments '("hello-world")
                 'options   {}})

  (check-equal? (parse-command-args '("hello" "world"))
                {'arguments '("hello" "world")
                 'options   {}})

  (check-equal? (parse-command-args '("--help"))
                {'arguments '()
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help"))
                {'arguments '("hello")
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help" "world" "args"))
                {'arguments '("hello")
                 'options   {'#:help '("world" "args")}})

  (check-equal? (parse-command-args '("--help" "hello"))
                {'arguments '()
                 'options   {'#:help "hello"}})

  (check-equal? (parse-command-args '("hello" "world" "--help" "--set-tab" "4"))
                {'arguments '("hello" "world")
                 'options   {'#:help #t
                             '#:set-tab 4}}))

----

As always, it's a good style to implement some helpers for
<<func/parse-command-args,+parse-command-args+>>.

.code::parse-command-args-helpers
[source,racket,linenums]
----
;; #lang racket

(define is-argument? #λ(not (string-starts-with? % "-")))

(module+ test
  (check-equal? (is-argument? "")     #t)
  (check-equal? (is-argument? "a")    #t)
  (check-equal? (is-argument? "-a")   #f)
  (check-equal? (is-argument? "--a")  #f)
  (check-equal? (is-argument? "-")    #f))

(define is-option? #λ(not (is-argument? %)))

(module+ test
  (check-equal? (is-option? "")     #f)
  (check-equal? (is-option? "a")    #f)
  (check-equal? (is-option? "-a")   #t)
  (check-equal? (is-option? "--a")  #t)
  (check-equal? (is-option? "-")    #t))

(define option->keyword
  #λ(string->keyword (~> (string->list %)
                       (dropf (λ (ch) (eq? #\- ch)))
                       list->string)))

(module+ test
  (check-equal? (option->keyword "-h")      '#:h)
  (check-equal? (option->keyword "--help")  '#:help)
  (check-equal? (option->keyword "---help") '#:help))

(define try-convert-value
  #λ(if-let [value (string->number %)]
      value
      (cond [(string=? "true" %)
             #t]
            [(string=? "false" %)
             #f]
            [else
             %])))

(module+ test
  (check-equal? (try-convert-value "1") 1)
  (check-equal? (try-convert-value "a") "a")
  (check-equal? (try-convert-value "true")  #t)
  (check-equal? (try-convert-value "false") #f))

----

=== Calling corresponding command

Function +run-command+ does exactly that, i.e. it calls corresponding command
and passes necessary arguments.

[[func/run-command]]
.code::run-command
[source,racket,linenums]
----
(define (run-command command args)
  (let* ([module-location (string->path
                           (get-path +ulquikit-location+
                                     (format "commands/~a.rkt"
                                             command)))]
         [run-func        (dynamic-require module-location 'run)]
         [args            (if (hash? args)
                              args
                              (parse-command-args args))]
         [main-args       (args 'arguments)]
         [keyword-list    (hash-keys (args 'options))]
         [val-list        (hash-values (args 'options))])
    (if (~> args 'options '#:help)
        (run-help command)
        (with-handlers ([exn:fail:contract?
                         (λ (e)
                           (displayln "=> Invalid option(s)")
                           (displayln e)
                           (newline)
                           (run-help command))])
          (keyword-apply run-func
                         keyword-list
                         val-list
                         main-args)))
    (newline)))

----

Besides <<func/run-command,+run-command+>>, we also have +run-help+ as a
helper to display help of a command.  +run-help+ simply reads the help file of
the corresponding command and returns its content.

.code::run-help
[source,racket,linenums]
----
(define (run-help command)
  (let* ([help-file (get-path +ulquikit-location+
                              (format "commands/~a.help.txt"
                                      command))])
    (displayln (read-file help-file))))

----

=== Putting all command things together

With all necessary functions implemented, module +command-core+ which all
other commands have to +required+ comes down to this little piece below:

.file::command-core.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "ulquikit.rkt")
(require "utils/path.rkt")
(require "utils/string.rkt")

(provide run-command
         (rename-out [run-help run-command-help]
                     [run-help run-help])
         display-command)

(module+ test
  (require rackunit))

(define (display-command title)
  (displayln (str "==== " title " ====")))

;; include::parse-command-args

;; include::run-command

;; include::run-help

----

The next big piece of Ulquikit is the +generate-html+ command which generates
HTML documents with some default options.

== Generating HTML

First, let's decide upon how this command is used:

.file::commands/generate-html.help.txt
[source,text,linenums]
----
Usage: generate-html [--from from] [--to to]

Generate HTMLs from literate documents.

  --from   either path to a directory where literate documents are stored, or
           path to one literate document, default: "src"
            
  --to     directory where HTMLs are generated, default: "generated-html"

Examples

Generate HTMLs from src/ to generated-html/ recursively
  ulqui generate-html

or explicitly
  ulqui generate-html --from src/ --to generated-html/

Generate HTMLs from literate-source/ to generated-documents/
  ulqui generate-html \
    --from literate-source/ \
    --to generated-documents

----

As in other commands, +generate-html+ also has a main function, which is named
+generate-html+ as well, taking 2 optional directories: source (of AsciiDoc
documents) and destination (where HTML documents are generated), namedly
+#:from+ and +#:to+ as in <<func/generate-src,+generate-src+>>.

.code::generate-html
[source,racket,linenums]
----
(define (generate-html #:from      [from "src"]
                       #:to        [to "generated-html"])
  (let* ([from  (get-path from)]
         [to    (get-path to)]
         [docs  (if (file-exists? from)
                    (let ([file (list from)])
                      (set! from (path->directory from))
                      file)
                    (list-all-adocs from))])
    (parameterize ([current-directory from])
      (for ([doc docs])
        (render-asciidoc doc
                         (get-relative-path to (get-output-file doc)))))))

----

Let's dig into some helpers for this function.  The first helper to notice is
+render-asciidoc+, used to build and run rendering command with AsciiDoctor.

By default, AsciiDoctor is invoked with +--doctype book+.  Customization could
be added later.

.code::render-asciidoc
[source,racket,linenums]
----
(define asciidoctor-format-command
  #λ(format "asciidoctor ~a -d book -o ~a" %1 %2))

(define (render-asciidoc input-file output-file)
  (displayln (str "-> " input-file " => " output-file))
  (system (asciidoctor-format-command input-file output-file)))

----

And last but not least, for +generate-html+ to be ready, we need a function to
extract file name and replace +.adoc+ extension with +.html+ extension.

.code::get-output-file
[source,racket,linenums]
----
(define get-output-file
  #λ(~> (file-name-from-path %)
      path->string
      (string-replace ".adoc" ".html")))

(module+ test
  (check-equal? (get-output-file "/tmp/tmp.adoc")   "tmp.html")
  (check-equal? (get-output-file "/tmp/world.adoc") "world.html"))

----

The code for command +generate-html+ is as simple as followed:

.file::commands/generate-html.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

(module+ test
  (require rackunit))

;; include::render-asciidoc

;; include::get-output-file

;; include::generate-html

(define (run #:from [from "src"]
             #:to   [to   "generated-html"])
  (display-command "Generating HTML")
  (generate-html #:from from
                 #:to   to))

----

== The +ulqui+ script

So far we have been going through all important internal components of
Ulquikit.  What's left to make a complete, usable application is the main
command that takes care of user interactive: the +ulqui+ script.  +ulqui+ is a
complete Racket module.

First and foremost, this module should be able to detect all built-in commands
residing in +commands/+ directory.  This task is simple and straightforward:
find all +.rkt+ files is +commands/+ directory and return them as a list
without their extensions.

.code::ulqui/list-commands
[source,racket,linenums]
----
(define (list-commands)
  (let* ([command-dir (get-path +ulqui-dir+ "../commands/")]
         [commands    (~>> (directory-list command-dir)
                        (map path->string)
                        (filter #λ(string-ends-with? % ".rkt"))
                        (map #λ(regexp-replace #px"\\.rkt$" % "")))])
    commands))

----

+ulqui+ might be liked, or copied indenpently, so the help of +ulqui+ should
should be within in source.  Besides, whenever help is called, +ulqui+ should
be able to detect all available commands and brief their helps.

.code::ulqui/display-help
[source,racket,linenums]
----
(define (display-help)
  (displayln
   @str{Usage: ulqui <command> [options] ...

Ulquikit is yet another literate programming tool, with the main tasks of
generating code and documentation from literate source.

Supported markup language: AsciiDoc.
Supported output formats for documentation: HTML.

Available commands:

})
  (let* ([commands   (list-commands)]
         
         [full-helps (map #λ(with-output-to-string
                              (λ ()
                                (run-help %))) commands)]
         
         [helps      (for/list ([text full-helps])
                       (let* ([lines (string-split text "\n" #:trim? #f)]
                              [usage-omitted (dropf lines
                                                    #λ(not (string=? % "")))]
                              [help (takef (rest usage-omitted)
                                           #λ(not (string=? % "")))])
                         (string-join help "\n")))])
    (map (λ (command help)
           (displayln (str (format (~a command
                                       #:width 15))
                           " :: "
                           help)))
         commands
         helps))
  (newline)
  (displayln
   @str{
Use 'ulqui help' or 'ulqui --help' to bring up this help.
Use 'ulqui help <command>' or 'ulqui <command> --help' to get help for a
command.
Use 'ulqui --version' to display current running version of Ulquikit.})
  (newline))

----

One important thing to note is that +ulqui+ script might be linked to and run
from different places.  Once it has been linked, Ulquikit directory is not the
directory that contains this script anymore, thus it needs to be re-calculated
and all functions which are imported need to be ++require++d manually:

.code::ulqui/require-utils
[source,racket,linenums]
----
(define +ulqui-script-path+
  (resolve-path (syntax-source #'here)))

(define +ulqui-dir+
  (let-values ([(base name must-be-dir?)
                (split-path +ulqui-script-path+)])
    base))

(define get-ulqui-module-path
  #λ(build-path +ulqui-dir+ %))

(define +ulquikit-version+
 (dynamic-require (get-ulqui-module-path "../ulquikit.rkt")
                  '+ulquikit-version+))

(define string-ends-with?
 (dynamic-require (get-ulqui-module-path "../utils/string.rkt")
                  'string-ends-with?))

(define get-path
  (dynamic-require (get-ulqui-module-path "../utils/path.rkt")
                   'get-path))

(define run-help
  (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                   'run-help))

(define run-command
 (dynamic-require (get-ulqui-module-path "../command-core.rkt")
                  'run-command))
----


Putting all things mentioned above together, we have the following +ulqui+
script.  To make the script as practical as possible, certain things should be
clarified:

* By default, running +ulqui+ alone usually means users need some help.  Thus
  running +ulqui+ is equivalent to running +ulqui help+.

* If users execute invalid command, this script also fallbacks to +ulqui
  help+ with a small error message.

.file::bin/ulqui
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

;; include::ulqui/display-version

;; include::ulqui/require-utils

;; include::ulqui/list-commands

;; include::ulqui/display-help

(module+ main
  (void
   (let* ([command-list (list-commands)]
          [arguments (vector->list (current-command-line-arguments))]
          [arg-list  (if (empty? arguments)
                         '("help")
                         arguments)]
          [command   (first arg-list)]
          [args      (rest arg-list)])
     (cond [(string=? "help" command)
            (if (empty? args)
                (display-help)
                (run-help (first args)))]
           [(string=? "--version" command)
            (display-version)]
           [(not (member command command-list))
            (displayln (str "-> Invalid command " command ".\n"))
            (display-help)]
           [else
            (run-command command args)]))))

----

Oh, and let's not forget this small but useful function: +display-version+

.code::ulqui/display-version
[source,racket,linenums]
----
(define (display-version)
  (displayln (str "Ulquikit v" +ulquikit-version+)))
----


== Managing Ulquikit source code

As Ulquikit grows, the need for a script/tool to manage source code,
release, ... arises.  This +schiffer+ script (named after last name of
http://en.wikipedia.org/wiki/List_of_Hollows_in_Bleach#Ulquiorra_Schiffer[Ulquiorra
Schiffer]) is born to fulfilled that need.

=== Generate source code and HTML documents, all at once

This function simply makes a call to <<command/generate-src,+generate-src+>>
and <<command/generate-html,generate-html>> commands.  Note that the
+schiffer+ script only has its use inside Ulquikit project, so when it's
generated, it's moved outside +generated-src+.  Also, all files in
+generated-src/bin/+ directory should be given executable permission.

.code::schiffer/generate-all
[source,racket,linenums]
----
(define (generate-src)
  (system "ulqui generate-src")

  (displayln "=> Giving executable permission to generated-src/bin/*")
  (system "chmod +x generated-src/bin/*")
  (newline)

  (displayln "=> Moving schiffer to current directory")
  (rename-file-or-directory "generated-src/bin/schiffer"
                            "schiffer-dev"
                            #t)
  (displayln "   generated-src/bin/schiffer => ./schiffer-dev")
  (newline)

  (displayln "=> Moving quick installation script to current directory")
  (rename-file-or-directory "generated-src/bin/quick-install.sh"
                            "quick-install.sh"
                            #t)
  (displayln "   generated-src/bin/quick-install.sh => ./quick-install.sh")
  (newline))

(define (generate-html)
  (system "ulqui generate-html")
  (newline))

(define (generate-all)
  (generate-src)
  (generate-html))

----

=== Update-self

This function simply copy and replace +schiffer+ script with +schiffer-dev+
without re-generating source code.

.code::schiffer/update-self
[source,racket,linenums]
----
(define (update-self)
  (displayln "=> Replacing schiffer with schiffer-dev")
  (copy-file "schiffer-dev" "schiffer" #t)
  (displayln "   ./schiffer-dev -> ./schiffer")
  (newline))

----

=== Mark current source as stable

Marking current generated source code as stable by replacing
+release/ulquikit+ with +generated-src+.  Note that this function/command does
*not* re-generate source code.

.code::schiffer/mark-stable
[source,racket,linenums]
----
(define (mark-stable)
  (displayln "=> Removing current stable")
  (delete-directory/files "release" #:must-exist? #f)
  (newline)

  (displayln "=> Creating stable directory: release")
  (make-directory* "release")
  (newline)

  (displayln "=> Copying current generated source to stable")
  (displayln "   generated-src -> release/ulquikit")
  (copy-directory/files "generated-src" "release/ulquikit")
  (newline)

  (displayln "=> Copying docs")
  (displayln "   generated-html -> release/ulquikit/docs")
  (copy-directory/files "generated-html" "release/ulquikit/docs")
  (newline))

----

=== Release

[[schiffer/mark-release]]
.code::schiffer/mark-release
[source,racket,linenums]
----
(define (mark-release)
  (mark-stable)
  (let* ([latest-tag       (~> (process "git tag")
                             first
                             port->string
                             string-split
                             last)]
         [filename         (format "ulquikit-~a.zip" latest-tag)]
         [zip-command      (format "zip -r ~a ulquikit" filename)]
         [checksum-command (format "md5sum ~a > ~a.md5"
                                   filename
                                   filename)])
    (parameterize [(current-directory "release")]
      (displayln (str "=> Creating release/" filename))
      (system zip-command)
      (newline)

      (displayln (str "=> Creating checksum for release/" filename))
      (system checksum-command)
      (displayln (str "   release/" filename " => release/" filename ".md5"))
      (newline))))

----


=== Run current dev version of Ulquikit

Running current Ulquikit dev version is done by calling
+generated-src/bin/ulqui+.

.code::schiffer/ulqui-dev
[source,racket,linenums]
----
(define (ulqui-dev args)
  (system (str "generated-src/bin/ulqui "
               (~> (map #λ(string-append "'" % "'") args)
                 (string-join " "))))
  (newline))

----

=== Run tests

By calling +raco test generated-src/*+.

.code::schiffer/run-tests
[source,racket,linenums]
----
(define (run-tests)
  (system "raco test generated-src/*")
  (newline))

----

=== Clean up

Simply removing +generated-html+ and +generated-src+ directories:

.code::schiffer/clean-up
[source,racket,linenums]
----
(define (clean-up)
  (displayln "=> Removing generated-html")
  (delete-directory/files "generated-html" #:must-exist? #f)
  (displayln "=> Removing generated-src")
  (delete-directory/files "generated-src" #:must-exist? #f)
  (newline))
----

=== Help

Of course, help is particularly useful.

.code::schiffer/help
[source,racket,linenums]
----
(define (help)
  (displayln @str{
Usage: schiffer <command> [options] ...

Schiffer is a simple build script for Ulquikit.

Available commands:

  generate-src  :: Generate Ulquikit source code to 'generated-src'.
  generate-html :: Generate Ulquikit HTML docs to 'generated-html'.
  generate-all  :: Call 'generate-src', then 'generate-html'.
  update-self   :: Update Schiffer, replace itself with './schiffer-dev'.
  mark-stable   :: Mark current 'generated-src' as stable by copying it into
                   'release/ulquikit'
  mark-release  :: Mark current stable in 'release/ulquikit' as release by
                   zipping it with latest Git tag name.  E.g.
                  'release/ulquikit' is zipped into 'release/ulquikit-v2.0.zip'.
  ulqui-dev     :: Analogous to 'generated-src/bin/ulqui'.
  clean-up      :: Clean up generated source and HTML.
  run-tests     :: Run all Ulquikit tests in 'generated-src/'.
  help          :: Print this help.

Note that only 'ulqui-dev' takes options.
})
  (newline))

----


=== Combine into +schiffer+

.file::bin/schiffer
[source,racket,linenums]
----
#!/usr/bin/env racket

;; include::license-header

#lang at-exp rackjure

(current-curly-dict hash)

(require net/url)

;; include::schiffer/generate-all

;; include::schiffer/update-self

;; include::schiffer/mark-stable

;; include::schiffer/mark-release

;; include::schiffer/ulqui-dev

;; include::schiffer/clean-up

;; include::schiffer/run-tests

;; include::schiffer/help

(module+ main
  (void
   (let* ([args    (current-command-line-arguments)]
          [command (vector-ref (if (zero? (vector-length args))
                                   #("")
                                   args)
                               0)])
     (match command
       ["generate-src"     (generate-src)]
       ["generate-html"    (generate-html)]
       ["clean"            (clean-up)]
       ["update-self"      (update-self)]
       ["mark-stable"      (mark-stable)]
       ["mark-release"     (mark-release)]
       [(or "ulqui-dev"
            "run-dev")     (ulqui-dev (vector->list (vector-drop args 1)))]
       [(or "test"
            "run-tests")   (run-tests)]
       [(or "generate-all"
            "build")       (generate-all)]
       [_                  (help)]))))
----

== Updating Ulquikit

As more versions of Ulquikit are released, having a way to update Ulquikit
from the command line is very helpful.  One way to do this is by adding
+update+ command, so that users could update Ulquikit to latest version just
by running:

[source,sh]
----
ulqui update
----

=== Retrieve latest version

Ulquikit is officially released via
https://help.github.com/articles/about-releases[Github Releases], which
provides this URL https://github.com/cmpitg/ulquikit/releases/latest pointing
to latest release.

First of all, let's +curl+ this URL to see how it's redirected:

[source,sh,linenums]
----
curl --head https://github.com/cmpitg/ulquikit/releases/latest

# HTTP/1.1 302 Found
# Server: GitHub.com
[snip]
# Location: https://github.com/cmpitg/ulquikit/releases/tag/v0.2
[snip]
----

So that's how it works, simple and straightforward.  The job now is to get the
"Location" attribute from HTTP header and grab the version.  With Racket's
http://docs.racket-lang.org/net/url.html[+net/url+] library, it becomes trivial:

.code::ulqui/latest-version
[source,racket,linenums]
----
(define +latest-release-url+
  (string->url "https://github.com/cmpitg/ulquikit/releases/latest"))

(define (get-latest-version)
  (~> (call/input-url +latest-release-url+
                      head-impure-port
                      port->string)
    string-split
    (dropf #λ(not (string=? "Location:" %)))
    second
    (#λ(regexp-match #rx"v(.*)" %))
    second))

----

Note that we use
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-impure-port%29%29[+head-impure-port+]
instead of
http://docs.racket-lang.org/net/url.html#%28def._%28%28lib._net%2Furl..rkt%29._head-pure-port%29%29[+head-pure-port+]
as the response might content body.

=== Download and replace Ulquikit

==== Construct download URL

Let's have a closer look: Version 2.0 has
https://github.com/cmpitg/ulquikit/releases/download/v0.2/ulquikit-v0.2.zip as
its download URL.  The filename +ulquikit-v0.2.zip+ certainly depends on
naming convention, which <<schiffer/mark-release,+schiffer+>> has got us
covered.  So all download URLs follow the following format:
+https://github.com/cmpitg/ulquikit/releases/download/v{latest-version}/ulquikit-v{latest-version}.zip+.
Based on that, we have this function to construct download URL of the latest
version:

.code::ulqui/construct-download-url
[source,racket,linenums]
----
(define (construct-download-url [version (get-latest-version)])
  (format "https://github.com/cmpitg/ulquikit/releases/download/v~a/ulquikit-v~a.zip"
          version
          version))
----

==== Download and unzip

There are a couple of ways to download and unzip the release file, among which
the following 2 are the most commonly used:

* Using Racket's own API - bad in performance and memory space.

* Calling shell commands - platform-dependant but much better in performance.

Let's make this work first then improve later.  I'm going to choose the 2^nd^
option for now.

Note that +system+ is used to call external commands, which in turn produce
some data to standard output and standard error.  Thus we make standard output
and standard error unbeffered during to +system+ call to achieve the best
result.

.code::ulqui/download-and-unzip
[source,racket,linenums]
----
(define (download-and-unzip version to-dir)
  (parameterize ([current-directory to-dir])
    (let ([url              (construct-download-url version)]
          [filename         (format "ulquikit-v~a.zip" version)]
          [out-buffer-mode  (file-stream-buffer-mode (current-output-port))]
          [err-buffer-mode  (file-stream-buffer-mode (current-error-port))])

      (with-handlers ([exn:fail?
                       (λ (_)
                         (file-stream-buffer-mode (current-output-port)
                                                  out-buffer-mode)
                         (file-stream-buffer-mode (current-error-port)
                                                  err-buffer-mode))])
        (file-stream-buffer-mode (current-output-port) 'none)
        (file-stream-buffer-mode (current-error-port) 'none)

        (displayln (str "-> Downloading from " url))
        (system (str "curl -O " url))

        (displayln (str "-> Unzipping " filename ", replacing old version with new version"))
        (system (str "unzip -o " filename))

        (displayln (str "-> Removing " filename))
        (delete-directory/files filename)

        (file-stream-buffer-mode (current-output-port) out-buffer-mode)
        (file-stream-buffer-mode (current-error-port) err-buffer-mode)))))

----

=== The +update+ command

.file::commands/update.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require net/url)

(require "../ulquikit.rkt")
(require "../command-core.rkt")
(require "../utils/path.rkt")

(provide run)

;; include::ulqui/latest-version

;; include::ulqui/construct-download-url

;; include::ulqui/download-and-unzip

(define (run)
  (display-command "Updating Ulquikit")
  (displayln (str "-> Current version: " +ulquikit-version+))
  (let ([latest-version (get-latest-version)])
    (displayln (str "   Latest version:  " latest-version))
    (cond [(string=? latest-version +ulquikit-version+)
           (newline)
           (displayln (str "   Congratulations! You are running the latest version of Ulquikit!"))]
          [else
           (download-and-unzip latest-version +ulquikit-location+)])))

----

Of course, a little piece of help text is always necessary.

.file::commands/update.help.txt
[source,text,linenums]
----
Usage: update

Update Ulquikit to latest version.

----

== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

=== Quick installation script

This comes in handy at times.  The script assumes that *users have already
installed Racket and Ruby*.

The user-friendliness provided by the script is the most important, so let's
decide upon how it looks like:

.file::bin/quick-install.sh
[source,sh,linenums]
----
#!/bin/sh

## include::quick-install/racket

## include::quick-install/ruby

## include::quick-install/asciidoctor

## include::quick-install/rackjure

## include::quick-install/ulquikit

----

Bourne shell is a horrible language, so even a simple check-and-make-decision
might end up look like:

[source,sh,linenums]
----
if [ `which some-exec >/dev/null 2>&1 && echo true || echo false` == "true" ]; then
   # Do-something
fi
----

Unfortunately, each part of this +quick-install.sh+ script requires that kind
of check.  Let's walk through them one by one.

==== Make sure Racket is installed

This task is simple done by checking whether +racket+ executable is found.
Note that it doesn't check Racket version.  The script fails if Racket is not
installed, thus the +exit 1+ command.

.code::quick-install/racket
[source,sh,linenums]
----
if [ `which racket >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Racket not found, please install it first."
    echo "   You might refer to your OS's package manager to install Racket,"
    echo "   or download it from: http://racket-lang.org/download/"
    echo "   Please MAKE SURE you have Racket 6+."
    echo "-> Installation aborted."
    exit 1
else
    echo "-> Found Racket.  MAKE SURE you have Racket 6+."
fi

----

==== Install Ruby 1.9 (using RVM) if necessary

.code::quick-install/ruby
[source,sh,linenums]
----
if [ `which ruby >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo "-> Ruby not found."
    echo "   You might refer to your OS's package manager to install Ruby."
    echo "   However, this script could install Ruby for you using RVM stable."
    echo "   Please refer to http://rvm.io for further information."

    echo -n "-> Would you like to install RVM stable single-user mode? [Y/n] "
    read DO_INSTALL_RVM

    if [ "$DO_INSTALL_RVM" == "" ] \
        || [ "$DO_INSTALL_RVM" == "y" ] \
        || [ "$DO_INSTALL_RVM" == "Y" ]; then
        echo "-> Installing Ruby 1.9 and RVM..."

        \curl -sSL https://get.rvm.io | bash -s stable
        [[ -f ~/.bashrc ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.bashrc)
        [[ -f ~/.zshrc  ]] && (echo 'source $HOME/.rvm/scripts/rvm' >> ~/.zshrc)
        source $HOME/.rvm/scripts/rvm
        rvm install 1.9
        rvm use 1.9 --default
    else
        echo "-> Installation aborted."
        exit 1
    fi
else
    echo "-> Found Ruby.  MAKE SURE you have Ruby 1.9+."
fi
----

==== Install AsciiDoctor if necessary

.code::quick-install/asciidoctor
[source,sh,linenums]
----
if [ `which asciidoctor >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> AsciiDoctor found."
else
    echo "-> Installing AsciiDoctor..."
    gem install -V asciidoctor
fi

----

==== Install Rackjure if necessary

.code::quick-install/rackjure
[source,sh,linenums]
----
if [ `(raco pkg show | grep rackjure) >/dev/null 2>&1 && echo t || echo f` == "t" ]; then
    echo "-> Rackjure found."
else
    echo "-> Installing Rackjure..."
    raco pkg install rackjure
fi

----

==== Install Ulquikit

NOTE: +DOWNLOAD_URL+ needs to change everytime there's new release.

.code::quick-install/ulquikit
[source,sh,linenums]
----
DOWNLOAD_URL=https://github.com/cmpitg/ulquikit/releases/download/v0.2.1/ulquikit-v0.2.1.zip

echo -n "-> Where would you like to install/update Ulquikit? (default: $HOME/) "
read ULQUIKIT_DEST
eval ULQUIKIT_DEST=$ULQUIKIT_DEST

if [ "$ULQUIKIT_DEST" == "" ]; then
    ULQUIKIT_DEST=$HOME/
fi

cd $ULQUIKIT_DEST

echo "-> Downloading latest version..."
wget -q "$DOWNLOAD_URL" -O ulquikit.zip

echo "-> Unpacking..."
unzip ulquikit.zip

echo "-> Removing zip file..."
rm -f ulquikit.zip

if [ `which ulqui >/dev/null 2>&1 && echo t || echo f` == "f" ]; then
    echo '-> Adding ulquikit/bin to your $PATH'
    [[ -f ~/.bashrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.bashrc)
    [[ -f ~/.zshrc ]] && (echo export PATH=$ULQUI_DEST/ulquikit/bin:'$PATH' >> ~/.zshrc)

    echo "-> Done!  Enjoy your time with literate programming!"
else
    echo '-> Found ulqui command in your $PATH.'
fi

export PATH=$ULQUI_DEST/ulquikit/bin:$PATH

----

== Other meta-information

I figure out it's a good practice to good the application's meta-information
into one module.  Currently, it only contain version information and a way to
retrieve location of Ulquikit.

.file::ulquikit.rkt
[source,racket,linenums]
----
;; include::license-header

#lang racket

(require racket/path)

(provide +ulquikit-version+
         +ulquikit-location+)

;; include::ulquikit-version

;; include::ulquikit-location

----

Retrieving location of Ulquikit is simple and straightforward, we'll use
+syntax-source+ to do that:

.code::ulquikit-location
[source,racket,linenums]
----
(define-values (+ulquikit-location+ _ __)
  (split-path (syntax-source #'here)))

----

== License header

Since Ulquikit is distributed under the terms of GPLv3, the license header is
necessary.

.code::license-header
[source,lisp]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014-2015 Nguyễn Hà Dương <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----

== Extras

=== Command list

=== Story: How the Racket version of Ulquikit was actually developed
