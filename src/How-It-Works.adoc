= Ulquikit - How it works
:Author: Nguyễn Hà Dương (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Ulquikit is written in literate programming itself with a small bootstrap
code.  This document is Ulquikit's literate source code.

To compile _and run_ Ulquikit, the following dependencies are required:

* http://asciidoctor.org[AsciiDoctor]
* http://racket-lang.org[Racket]

Ulquikit contains 2 parts:

* Bootstrap part: small and straightforward, consists of several Racket files
  to extract source code and documents from all AcsciiDoc files in +src/+

** To generate source code, run +src/bootstrap/generate-src.rkt+

** To generate documentation, run +src/bootstrap/generate-docs.rkt+

* Main part: this file.

Let's dive into some terminology first

== Terminology

* A *code block* is an AsciiDoc code block.

* A *snippet* is a code block with Ulquikit-defined title and delimiter
  +----+.  By default, a code block title that starts +file::+ and +code::+
  defines a _file snippet_ and _code snippet_, respectively:

** A *file snippet* is a snippet producing a source file.
** A *code snippet* is a snippet storing source code that can be included into
   other snippets.

* An *include directive* is a line of code that:

** belongs to a snippet
** has the format of +xx include::some-snippet-name+ where +xx+ are two
   identical characters denoting a comment.  Ulquikit can recogize the
   following comment types: +//+, +;;+, +##+, +--+, or C-stype +/*
   include::some-snippet-name */+, or XML-style +<!--
   include::some-snippet-name -->+.

== Extracting and including snippets

Ulquikit works by searching for all AsciiDoc documents inside
+<project-root>/src+ directory, building a database of snippets, including
them into each other if necessary, then generating documentation and source
code.  Hence, the following functions are probably the most interesting ones:

* <<func/extract-snippets-from-file,+extract-snippets-from-file+>>, which
  helps extract snippets from a file
* <<func/include-snippet,+include-snippet+>>, which helps
  <<section/include-snippets,include snippets>> into each other

Let's talk about +extract-snippets-from-file+ first:

[[section/extract-snippets]]
=== Extracting snippets

The first thing to do is probably to decide how snippets are stored.  This is
very important since every change made to this data structure would affect
code later one.

Each snippet is a hash with following format:

[[snippet-format]]
[source,racket,linenums]
----
{'type snippet-type          <1>
 'name snippet-name          <2>
 'linenum line-number        <3>
 'lines snippet-lines        <4>
 'processed? processed?}     <5>
----
<1> is either +'file+ or +'code+
<2> is the name of the snippet; e.g. snippet with title +file::something+ has
+something+ as its name.  Note that snippet name is _a string_.
<3> is the line number from the literate source code from where the snippet is
extracted
<4> is the content of the snippet as a list of lines, this is for performance
purpose
<5> determines whether this snippet has been processed? to include others, when
created for the first time, +'processed?+ is always +#f+.  It's only changed
after the snippet has been passed through
<<include-snippet,+include-snippet+>>

IMPORTANT: Snippets should never be created by directly by using hash.  They
should be created with <<func/create-snippet,+create-snippet+>>.

Since a snippet stores a list of lines as its content, it'd be convenient to
have a helper that joins those lines into a complete string:

.code::get-snippet-content
[source,racket,linenums]
----
;; lang racket

(define get-snippet-content
  #λ(string-join (% 'lines) "\n"))

----

+create-snippet+ is simply implemented as followed:

[[func/create-snippet]]
.code::create-snippet
[source,racket,linenums]
----
;; #lang racket

;; include::get-snippet-content

(define (create-snippet #:type type
                        #:name name
                        #:linenum linenum
                        #:lines lines
                        #:processed? [processed? #f])
  (let ([type (if (symbol? type)
                  type
                  (string->symbol type))]
        [name (if (symbol? name)
                  (symbol->string name)
                  name)]
        [lines (if (string? lines)
                   (string-split lines "\n" #:trim? #f)
                   lines)])
    {'type type
     'name name
     'linenum linenum
     'lines lines
     'processed? processed?}))

(module+ test
  (check-equal? (create-snippet #:type 'file
                                #:name 'hello-world
                                #:linenum 10
                                #:lines '("Hmm"))
                {'type 'file
                 'name "hello-world"
                 'linenum 10
                 'lines '("Hmm")
                 'processed? #f})
  (check-equal? (create-snippet #:type "string"
                                #:name "string"
                                #:linenum 100
                                #:lines "string")
                {'type 'string
                 'name "string"
                 'linenum 100
                 'lines '("string")
                 'processed? #f}))

----

Now the helper +create-snippet+ is ready.  Let's move on to
+extract-snippets-from-file+.

+extract-snippets-from-file+ needs to determine whether _a line in a code
block_ belongs to a _code snippet_, or _file snippet_, or none of those; then
extracts the content of the code block and store it if necessary.  Let's have
a look at 3 types of code block to see how we could tackle this problem:

* A _code snippet_ has the following format:
+
[listing]
..........
.code::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........

* A _file snippet_ shares the same structure as a _code snippet_:
+
[listing]
..........
.file::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........

* A non-snippet code block is any block without +code::...+ or +file::...+ as
  its title:
+
[listing]
..........
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>

....                            <3>
This is a literal block
....                            <4>
..........

<1> block title
<2> block type
<3> block delimiter
<4> block delimiter

As we can clearly see from the 3 examples, _code snippets_ and _file snippets_
could be determined by checking 2^nd^ previous line from block delimiter to
see if it starts with +.file::+ or +.code::+.  Everything between the 2
delimiters is stored as the content of the snippet.

Hence, we have the following algorithm for +extract-snippets-from-file+:

* Read the content of a file

* Break the content into lines preserving line numbers (call +string-split+
  with +#:trim? #f+).

* For each line:

** If we're already inside a snippet:

*** Complete a snippet and add it to snippet list if current line is a block
    delimiter (i.e. +----+)

*** Add current line to the current snippet's content if current line is not a
    block delimiter

** If we're outside a snippet, we only care if current line is a block
   delimiter (i.e. +----+):

*** If this block has a title that marks the beginning of a snippet (i.e. the
    2^nd^ previous line starts with +.file::+ or +.code::+), extract snippet
    name and add a new snippet.  Otherwise

*** If this block does not mark the beginning of a snippet, ignore it.

[[func/extract-snippets-from-file]]
.code::extract-snippets-from-file
[source,racket,linenums]
----
;; include::extract-snippets-from-file-helpers

(define (extract-snippets-from-file path)
  (let* ([file-content (read-file path)]
         [lines        (string-split file-content "\n" #:trim? #f)]

         [snippets        (box {'file {}
                                'code {}})]

         [prev-prev-line  (box "")]
         [prev-line       (box "")]

         [snippet-type    (box null)]
         [snippet-lines   (box '())]
         [snippet-name    (box "")]
         [snippet-linenum (box 0)]
         [inside-snippet  (box #f)])

    (for ([line-num    (in-naturals 1)]
          [line        (in-list lines)])

      (cond [(and (unbox inside-snippet)
                  (not (is-block-delimiter? line)))

             (box-swap! snippet-lines append (list line))]

            [(and (unbox inside-snippet)
                  (is-block-delimiter? line))

             (box-set! inside-snippet #f)
             (box-swap! snippets
                        add-snippets
                        (create-snippet #:type (unbox snippet-type)
                                        #:name (unbox snippet-name)
                                        #:linenum (unbox snippet-linenum)
                                        #:lines (unbox snippet-lines)))]
            [(is-block-delimiter? line)

             (when (is-block-title? (unbox prev-prev-line))
               (box-set! inside-snippet #t)

               (box-set! snippet-type (get-snippet-type (unbox prev-prev-line)))
               (box-set! snippet-name (get-snippet-name (unbox prev-prev-line)))
               (box-set! snippet-lines '())
               (box-set! snippet-linenum (dec line-num)))])

      ;; Always update previous line
      (box-set! prev-prev-line (unbox prev-line))
      (box-set! prev-line      line))

    (unbox snippets)))

----

Of course, for +extract-snippets-from-file+ to function, the following helpers are
necessary:

.code::extract-snippets-from-file-helpers
[source,racket,linenums]
----
(define is-block-delimiter?
  #λ(regexp-match? #rx"^----( *)$" %))

(module+ test
  (check-equal? (is-block-delimiter? "----")    #t)
  (check-equal? (is-block-delimiter? " ----")   #f)
  (check-equal? (is-block-delimiter? "---- ")   #t)
  (check-equal? (is-block-delimiter? "----  ")  #t)
  (check-equal? (is-block-delimiter? "----a")   #f))

(define is-block-title?
  #λ(regexp-match? #rx"^\\.(file|code)::" %))

(module+ test
  (check-equal? (is-block-title? ".file::something")       #t)
  (check-equal? (is-block-title? ".file::something else")  #t)
  (check-equal? (is-block-title? ".file::")                #t)
  (check-equal? (is-block-title? ".file:something")        #f))

(define get-snippet-type
  #λ(~> (string-rest %)
      (string-split "::")
      (list-ref 0)
      string->symbol))

(module+ test
  (check-equal? (get-snippet-type ".file::")  'file)
  (check-equal? (get-snippet-type ".code::")  'code))

(define get-snippet-name
  #λ(~> (string-rest %)
      (string-split "::")
      (append '(""))
      (list-ref 1)))

(module+ test
  (check-equal? (get-snippet-name ".file::")     "")
  (check-equal? (get-snippet-name ".code::")     "")
  (check-equal? (get-snippet-name ".file::abc")  "abc")
  (check-equal? (get-snippet-name ".code::a b")  "a b"))

(define (add-snippets snippets snippet)
  (let* ([type (snippet 'type)]
         [name (snippet 'name)]

         [snippets/typed         (snippets type)]
         [snippets/typed/updated (snippets/typed name snippet)])
    (snippets type snippets/typed/updated)))

(module+ test
  (check-equal? (add-snippets {'file {}
                               'code {}}
                              (create-snippet #:type 'file
                                              #:name 'hello
                                              #:linenum 10
                                              #:lines '("Something")))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'lines '("Something")
                                 'processed? #f}}
                 'code {}})

  (check-equal? (add-snippets {'file {"hello" {'type 'file
                                               'name "hello"
                                               'linenum 10
                                               'lines '("Something")
                                               'processed? #f}}
                               'code {}}
                              (create-snippet #:type 'code
                                              #:name 'say-something
                                              #:linenum 100
                                              #:lines '("Something else")))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'lines '("Something")
                                 'processed? #f}}
                 'code {"say-something" {'type 'code
                                         'name "say-something"
                                         'linenum 100
                                         'lines '("Something else")
                                         'processed? #f}}}))

----

As a result, +extract-snippets+, which extracts snippets from all AsciiDoc
documents in a directory recursively, makes use of
+extract-snippets-from-file+ to function.  +extract-snippets+ takes a path and
return a hash of following format:

[source,racket]
----
{'file file-snippets-hash
 'code code-snippets-hash}
----

+file-snippets-hash+ and +code-snippets-hash+ follow <<snippet-format,snippet
format>> defined above.

.code::extract-snippets
[source,racket,linenums]
----
;; include::extract-snippets-from-file

(define (extract-snippets from-dir)
  (for/fold ([snippet {}])
      ([file (list-all-adocs (standardize-path from-dir))])
    (dict-merge snippet (extract-snippets-from-file file))))

(module+ test
  (let* ([temp-dir (get-relative-path (get-temp-dir)
                                      "./ulqui-extract-snippets")]

         [expected-code-snippets
          {"main-program" (string-join
                           '(";; include::utils"
                             ""
                             "(module+ main"
                             "  (displayln (string-reverse \"¡Hola mundo!\")))"
                             "")
                           "\n")
           "use-rackjure" (string-join
                           '("#lang rackjure"
                             "(current-curly-dict hash)")
                           "\n")
           "license-header" ";; Just a sample license header."
           "utils" ";; include::utils-string"
           "utils-string" (string-join
                           '("(define (string-reverse str)"
                             "  (~> (string->list str)"
                             "    reverse"
                             "    list->string))")
                           "\n")}]

         [expected-file-snippets
          {"/tmp/tmp.rkt" (string-join
                           '(";; include::license-header"
                             ""
                             ";; include::use-rackjure"
                             ""
                             ";; include::main-program"
                             ""
                             "== Main program"
                             "")
                           "\n")}]

         [file-list '("Main"
                      "License"
                      "inside/Utils"
                      "inside/Utils-String")]
         [source-files (for/list ([name (in-list file-list)])
                         (get-relative-path (format "~a./~a.adoc"
                                                    temp-dir
                                                    name)))]
         [content
          {"Main" (string-join
                   (list "= A document"
                         ""
                         "Just a hello world program"
                         ""
                         ".file::/tmp/tmp.rkt"
                         "[source,racket,linenums]"
                         "----"
                         (expected-file-snippets "/tmp/tmp.rkt")
                         "----"
                         ".code::main-program"
                         "[source,racket,linenums]"
                         "----"
                         (expected-code-snippets "main-program")
                         "----"
                         ".code::use-rackjure"
                         "[source]"
                         "----"
                         (expected-code-snippets "use-rackjure")
                         "----"
                         "")
                   "\n")
           "License" (string-join
                      (list "= License header"
                            ""
                            ".code::license-header"
                            "[source,racket]"
                            "----"
                            (expected-code-snippets "license-header")
                            "----")
                      "\n")
           "inside/Utils" (string-join
                           (list "= Utils"
                                 ""
                                 "Right now, we just want to include string utililities."
                                 ""
                                 ".code::utils"
                                 "[source,racket,linenums]"
                                 "----"
                                 (expected-code-snippets "utils")
                                 "----")
                           "\n")
           "inside/Utils-String" (string-join
                                  (list "= String Utilities"
                                        ""
                                        ".code::utils-string"
                                        "[source,racket,linenums]"
                                        "----"
                                        (expected-code-snippets "utils-string")
                                        "----")
                                  "\n")}])
    (with-handlers ([exn:fail? #λ(remove-dir temp-dir)])
      (remove-dir temp-dir)
      (create-dir (get-relative-path temp-dir
                                     "./inside"))
      (for ([(filename content) (in-hash content)])
        (let ([path (get-relative-path temp-dir
                                       (format "./~a.adoc" filename))])
          (display-to-file content path)))

      (let* ([snippets (extract-snippets temp-dir)]
             [code-snippet (get-code-snippets snippets)]
             [file-snippet (get-file-snippets snippets)])

        (for ([(name snippet) code-snippet])
          (check-equal? (get-snippet-content snippet)
                        (expected-code-snippets name)))

        (for ([(name snippet) file-snippet])
          (check-equal? (get-snippet-content snippet)
                        (expected-file-snippets name))))
      (remove-dir temp-dir))))
----

After +extract-snippets+, the next important function is +include-snippet+,
which is use to include other snippets into one targeted snippet.  Let's see
how we could implement it.

[[section/include-snippets]]
=== Including snippets into each other

+include-snippet+ should take 2 arguments: a hash containing all snippets,
and the snippet which needs to be checked and included.  Thus this function
has the following signature: +(include-snippet snippets target)+
+include-snippet+ working by browsing its content, one line at a time, then
replace the line with +include+ directive with the corresponding _code
snippet_.  If no snippet is found, leave that line as-is.

Note that there are a couple things to bring into concern there:

* Snippet A includes snippet B, snippets B includes snippets C and D.  So the
  best scenario is to include C and D into B while we're actually
  processing A.  I.e. +include-snippet+ should be recursive to accumulate the
  results.

* Also because of the above reason, +snippets+ should be able to receive the
  changes across all calls recursive to +include-snippet+.  I.e. consider
  this dummy, incorrect implementation:
+
[source,racket,linenums]
----
(define (include-snippet snippets target)
  (unless (= (snippets 'a) 12)
    ;; Increase (snippets 'a)
    (include-snippet snippets new-target)))

(let ([snippets {'a 10}])
 (include-snippet snippets some-target))

(displayln (snippets 'a))
;; ⇨ 12

----
+
As you can see after returning from any call, the value of snippets should be
changed as it is changed inside those calls.
+
One of the solutions for this is to construct a helper and put +snippets+ into
a +box+ to make it safely immutable, then change it value for each time the
helper is call.

.+box+ and mutability
[TIP]
This is a perfect example of safe use mutable values in combination with
http://docs.racket-lang.org/reference/boxes.html[+box+].

* Snippet A includes snippet B, then snippet B includes snippet A again,
  creating circular dependency.  To prevent this, a list of currently included
  snippet must be kept track of.  If a snippet has already been in the track,
  include it but don't process it.

WARNING: In case of circular dependency, the results are *unexpected*.  Thus,
make sure snippets are well-managed.

Henceforth, our helper will takes the signature: +(process-include-snippet
target track)+

With all the reasons stated above, we have this implementation:

[[func/include-snippet]]
.code::include-snippet
[source,racket,linenums]
----
;; lang racket

;; include::include-snippet-helpers

(define (include-snippet boxed
                         target
                         [included? {}])
  (define updated-included? (included? (target 'name) #t))
  (unless (target 'processed?)
    (let* ([lines
            (for/list ([line (target 'lines)])
              (if (is-include-directive? line)
                  (let* ([included-snippet-name (get-included-snippet-name line)]
                         [snippet-to-include    (get-snippet-by-name (unbox boxed)
                                                                     included-snippet-name)])
                    (cond [(or (updated-included? included-snippet-name)
                               (not snippet-to-include))

                           ;; This snippet has already been included on the
                           ;; track or there's no such snippet ⇨ do nothing
                           line]

                          [(snippet-to-include 'processed?)

                           ;; When the snippet is already processed, simply
                           ;; return it
                           (string-join (snippet-to-include 'lines) "\n")]

                          [else

                           ;; When the snippet we're about to include exists
                           ;; and hasn't been processed
                           (include-snippet boxed
                                            snippet-to-include
                                            (updated-included? included-snippet-name #t))

                           ;; Of course, then we must return it after
                           ;; processed
                           (~> (get-snippet-by-name (unbox boxed)
                                                    included-snippet-name)
                             'lines
                             (string-join "\n"))]))

                  line))]

           [new-snippet (create-snippet #:type (target 'type)
                                        #:name (target 'name)
                                        #:linenum (target 'linenum)
                                        #:lines lines
                                        #:processed? #t)])
      (update-snippet/boxed boxed new-snippet))))

(module+ test
  (let* ([file-snippet-tmp {'name "/tmp/tmp.rkt"
                            'type 'file
                            'lines '(";; include::A")
                            'linenum 10}]
         [snippets {'file {"/tmp/tmp.rkt" file-snippet-tmp}
                    'code {"A" {'name "A"
                                'type 'code
                                'lines '("World" ";; include::B")
                                'linenum 20}
                           "B" {'name "B"
                                'type 'code
                                'lines '("Hello")
                                'linenum 30}
                           "C" {'name "C"
                                'type 'code
                                'lines '("Unprocessed")
                                'linenum 30
                                'processed? #f}}}]
         [boxed (box snippets)])
    (include-snippet boxed file-snippet-tmp {})
    (check-equal? (unbox boxed)
                  {'file {"/tmp/tmp.rkt" {'name "/tmp/tmp.rkt"
                                          'type 'file
                                          'lines '("World\nHello")
                                          'linenum 10
                                          'processed? #t}}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" "Hello")
                               'linenum 20
                               'processed? #t}
                          "B" {'name "B"
                               'type 'code
                               'lines '("Hello")
                               'linenum 30
                               'processed? #t}
                          "C" {'name "C"
                               'type 'code
                               'lines '("Unprocessed")
                               'linenum 30
                               'processed? #f}}}))

  (let* ([snippet-a {'name "A"
                     'type 'code
                     'lines '("World" ";; include::B")
                     'linenum 20}]
         [snippets {'file {}
                    'code {"A" snippet-a
                           "B" {'name "B"
                                'type 'code
                                'lines '("Hello" ";; include::A")
                                'linenum 30}}}]
         [boxed (box snippets)])
    (include-snippet boxed snippet-a {})
    (check-equal? (unbox boxed)
                  {'file {}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" "Hello\n;; include::A")
                               'linenum 20
                               'processed? #t}
                          "B" {'name "B"
                               'type 'code
                               'lines '("Hello" ";; include::A")
                               'linenum 30
                               'processed? #t}}}))

  (let* ([snippet-a {'name "A"
                     'type 'code
                     'lines '("World" ";; include::B")
                     'linenum 20}]
         [snippets {'file {}
                    'code {"A" snippet-a}}]
         [boxed (box snippets)])
    (include-snippet boxed snippet-a {})
    (check-equal? (unbox boxed)
                  {'file {}
                   'code {"A" {'name "A"
                               'type 'code
                               'lines '("World" ";; include::B")
                               'linenum 20
                               'processed? #t}}})))

;; (define (include-snippet snippets target)
;;   (let* ([boxed (box snippets)]
;;          [snippet-name (target 'name)])
;;     (include-snippet boxed
;;                              #:name snippet-name
;;                              #:included {})))

----

As we can see, +include-snippet+ makes use of a lot of helpers.  All of them
are short and easily implemented like so:

.code::include-snippet-helpers
[source,racket,linenums]
----
(define (update-snippet/boxed snippets/box snippet)
  (let* ([type (snippet 'type)]
         [name (snippet 'name)])
    (box-swap! snippets/box
               (λ (snippets)
                 (let* ([snippets/typed (snippets type)]
                        [snippets/typed/updated (snippets/typed name snippet)]
                        [snippets/updated (snippets type snippets/typed/updated)])
                   snippets/updated)))))

(module+ test
  (let* ([snippets {'file {}
                    'code {"hello" {'type 'code
                                    'name "hello"
                                    'lines '("original")
                                    'linenum 20
                                    'processed? #f}}}]
         [snippets/box (box snippets)])
    (update-snippet/boxed snippets/box
                          {'type 'code
                           'name "hello"
                           'lines '("changed")
                           'linenum 10
                           'processed? #t})
    (check-equal? (unbox snippets/box)
                  {'file {}
                   'code {"hello" {'type 'code
                                   'name "hello"
                                   'lines '("changed")
                                   'linenum 10
                                   'processed? #t}}})))

(define is-include-directive?
  #λ(or (regexp-match? #px"^[#;/-]{2} include::.*" (string-trim %))
        (regexp-match? #px"^<!-- include::.* -->" (string-trim %))
        (regexp-match? #px"^/\\* include::.* \\*/" (string-trim %))))

(module+ test
  (check-equal? (is-include-directive? "  ;; include::") #t)
  (check-equal? (is-include-directive? ";; include::") #t)
  (check-equal? (is-include-directive? "a;; include::") #f)
  (check-equal? (is-include-directive? ";; include::something") #t)
  (check-equal? (is-include-directive? "## include::something") #t)
  (check-equal? (is-include-directive? "// include::something") #t)
  (check-equal? (is-include-directive? "/* include::something */") #t)
  (check-equal? (is-include-directive? "<!-- include::something -->") #t)
  (check-equal? (is-include-directive? "a <!-- include::something -->") #f))

(define (get-included-snippet-name line)
  (if (is-include-directive? line)
      (let* ([line (string-trim line)]
             [line-2 (if (string-ends-with? line " -->")
                         (first (string-split line " -->"))
                         line)]
             [line-3 (if (string-ends-with? line-2 " */")
                         (first (string-split line-2 " */"))
                         line-2)]
             [splitted (string-split line-3 "include::")])
        (if (> (length splitted) 1)
            (last splitted)
            ""))
      ""))

(module+ test
  (check-equal? (get-included-snippet-name "  ;; include::") "")
  (check-equal? (get-included-snippet-name ";; include::") "")
  (check-equal? (get-included-snippet-name ";; include::something") "something")
  (check-equal? (get-included-snippet-name "## include::something") "something")
  (check-equal? (get-included-snippet-name "// include::something") "something")
  (check-equal? (get-included-snippet-name "/* include::something */") "something")
  (check-equal? (get-included-snippet-name "<!-- include::something -->") "something")
  (check-equal? (get-included-snippet-name "a <!-- include::something -->") ""))

(define (get-snippet-by-name snippets
                             name
                             #:type [type 'code])
  (~> snippets type name))
----

And that concludes the most important functions of Ulquikit.  Those functions
are used to implement the <<section/generate-source,+generate-src+>> right below.

=== Generating source code

Once snippets are extracted and included into each other, the act of
generateing source code becomes trivial, as implemented in +generate-src+
below.

.code::generate-src
[source,racket,linenums]
----
;; lang racket

;; include::create-snippet

;; include::extract-snippets

;; include::include-snippet

;; include::generate-snippets-helpers

(define (generate-src #:from [from "src"]
                      #:to   [to   "generated-src"])
  (let* ([from (get-path from)]
         [to   (get-path to)])
    (~> (extract-snippets from)
      (include-file-snippets)
      (generate-src-files to))))

----

The ultimate goal of generating source code is to produce files, so we only
need to include other snippets into file snippets.  +include-file-snippets+
does exactly that.  This function takes a hash of snippets as a result of the
call to +extract-snippets+ and returns a hash of snippets with all file
snippets <<section/include-snippets,included>>.  Let's combine the implement
of +include-file-snippets+ and +generate-src-files+ to make a complete set of
helpers for +generate-src+.

.code::generate-snippets-helpers
[source,racket,linenums]
----
;; lang racket

(define (include-file-snippets snippets)
  (let ([boxed (box snippets)]
        [file-snippets/names (hash-keys (get-file-snippets snippets))])
    (for ([target-name file-snippets/names])
      (let* ([target (~> snippets 'file target-name)])
        (include-snippet boxed target {})))
    (unbox boxed)))

(define (generate-src-files snippets to)
  (for ([(name snippet) (get-file-snippets snippets)])
    (let* ([path    (path->string (get-relative-path to name))]
           [content (get-snippet-content snippet)])
      (create-dir (path->directory path))
      (displayln (~a "-> Writing to " path))
      (display-to-file content path #:exists 'truncate/replace))))

(define get-file-snippets #λ(% 'file #:else {}))

(define get-code-snippets #λ(% 'code #:else {}))

----

Once all functions are ready, let's write a command to generate source code.

=== Anatomy of a Ulquikit command

Ulquikit commands are actually a Racket modules, residing in +commands/+.  The
name of the module (without +.rkt+ extension of course) is the actual command.
E.g. +commands/generate-src.rkt+ implements +generate-src+ command.

As a rule of thumb, each command has to provide at least 2 functions: +run+
and +help+:

* Command line arguments are parsed and passed through +run+ function.  Named
  arguments are automatically converted to either boolean or number and passed
  as Racket keywords.
+
E.g.

** +ulqui generate-src+ calls ++commands/generate-src++'s +(run)+.
** +ulqui generate-src some-file+ calls ++commands/generate-src++'s +(run "some-file")+.
** +ulqui generate-src --from file1 --to file2+ calls
   ++commands/generate-src++'s +(run #:from "file1" #:to "file2")+.

* When +ulqui help command-name+ or +ulqui command-name --help+ is invoked,
  the +help+ function that belongs to +commands/command-name.rkt+ module is
  called.  The same effect could be achieved by calling +(run #:help #t)+.
  This the +help+ function takes no arguments and returns a string that would
  be displayed as help.

* All commands must import +command-core.rkt+ (relative to command directory:
  +../command-core.rkt+).

With all that has been said, let's move on to the function which is used to
parse command line arguments.

==== Parsing command line arguments +parse-command-args+

This function takes all arguments passed to the command line as a list of
string and returns a map of following format:

[source,racket]
----
{'arguments list-of-arguments  <1>
 'options   hash-of-options}   <2>
----
<1> main arguments collected as a list, with the same order as they are at the
command line
<2> options are collected a hash; options that have no values are set to +#t+

[[func/parse-command-args]]
.code::parse-command-args
[source,racket,linenums]
----
;; include::parse-command-args-helpers

(define (parse-command-args args)
  (let ([arguments (takef args is-argument?)]
        [rest-args (dropf args is-argument?)])
    (let parse-options ([rest-args  rest-args]
                        [options    {}])
      (if (empty? rest-args)
          {'arguments arguments
           'options   options}
          (let* ([option-name   (first rest-args)]
                 [option-values (takef (drop rest-args 1) is-argument?)]
                 [rest-args     (dropf (rest rest-args)   is-argument?)]

                 [option-values/converted (map try-convert-value option-values)]

                 [name   (option->keyword option-name)]
                 [values (cond [(zero? (length option-values/converted))
                                #t]
                               [(= (length option-values/converted) 1)
                                (first option-values/converted)]
                               [else
                                option-values/converted])])
            (parse-options rest-args
                           (options name values)))))))

(module+ test
  (check-equal? (parse-command-args '())
                {'arguments '()
                 'options   {}})

  (check-equal? (parse-command-args '("hello-world"))
                {'arguments '("hello-world")
                 'options   {}})

  (check-equal? (parse-command-args '("hello" "world"))
                {'arguments '("hello" "world")
                 'options   {}})

  (check-equal? (parse-command-args '("--help"))
                {'arguments '()
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help"))
                {'arguments '("hello")
                 'options   {'#:help #t}})

  (check-equal? (parse-command-args '("hello" "--help" "world" "args"))
                {'arguments '("hello")
                 'options   {'#:help '("world" "args")}})

  (check-equal? (parse-command-args '("--help" "hello"))
                {'arguments '()
                 'options   {'#:help "hello"}})

  (check-equal? (parse-command-args '("hello" "world" "--help" "--set-tab" "4"))
                {'arguments '("hello" "world")
                 'options   {'#:help #t
                             '#:set-tab 4}}))

----

As always, it's a good style to implement some helpers for
<<func/parse-command-args,+parse-command-args+>>.

.code::parse-command-args-helpers
[source,racket,linenums]
----
;; #lang racket

(define is-argument? #λ(not (string-starts-with? % "-")))

(module+ test
  (check-equal? (is-argument? "")     #t)
  (check-equal? (is-argument? "a")    #t)
  (check-equal? (is-argument? "-a")   #f)
  (check-equal? (is-argument? "--a")  #f)
  (check-equal? (is-argument? "-")    #f))

(define is-option? #λ(not (is-argument? %)))

(module+ test
  (check-equal? (is-option? "")     #f)
  (check-equal? (is-option? "a")    #f)
  (check-equal? (is-option? "-a")   #t)
  (check-equal? (is-option? "--a")  #t)
  (check-equal? (is-option? "-")    #t))

(define option->keyword
  #λ(string->keyword (~> (string->list %)
                       (dropf (λ (ch) (eq? #\- ch)))
                       list->string)))

(module+ test
  (check-equal? (option->keyword "-h")      '#:h)
  (check-equal? (option->keyword "--help")  '#:help)
  (check-equal? (option->keyword "---help") '#:help))

(define try-convert-value
  #λ(if-let [value (string->number %)]
      value
      %))

(module+ test
  (check-equal? (try-convert-value "1") 1)
  (check-equal? (try-convert-value "a") "a"))
----

==== Calling corresponding command

Function +run-command+ does exactly that, i.e. it calls corresponding command
and passes necessary arguments.

.code::run-command
[source,racket,linenums]
----
(define (run-command command args)
  (let* ([module-location (string->path
                           (get-path +this-directory+
                                     (format "commands/~a.rkt"
                                             command)))]
         [run-func        (dynamic-require module-location 'run)]
         [args            (if (hash? args)
                              args
                              (parse-command-args args))]
         [main-args       (args 'arguments)]
         [keyword-list    (hash-keys (args 'options))]
         [val-list        (hash-values (args 'options))]
         )
    (keyword-apply run-func
                   keyword-list
                   val-list
                   main-args)
    ))
With all necessary functions implemented, +command-core+ comes down to this
little piece below:

.file::command-core.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "utils/path.rkt")
(require "utils/string.rkt")

(provide (all-defined-out))

(require racket/runtime-path)
(define-runtime-path +this-directory+ ".")

(module+ test
  (require rackunit))

(define (display-command title)
  (displayln (str "----> " title)))

(define (run-help command)
  (eval `(local-require ,(str command ".rkt")))
  (eval '(help)))

;; include::parse-command-args

;; include::run-command

----

=== Command: +generate-src+


.file::commands/generate-src.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")

(require "../utils/utils.rkt")
(require "../utils/path.rkt")
(require "../utils/string.rkt")

;; (provide run
;;          help)

(module+ test
  (require rackunit))
  
;; include::generate-src

;; include::commands/generate-src/run

;; include::commands/generate-src/help
----

== Utility functions

See link:Utilities.html[Utilities].

== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

== License header

Of course, since Ulquikit is distributed under the terms of GPLv3, the license
header is necessary.

.code::license-header
[source,racket]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014 Nguyễn Hà Dương <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----
