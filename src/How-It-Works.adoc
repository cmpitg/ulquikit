= Ulquikit - How it works
:Author: Nguyễn Hà Dương (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Ulquikit is written in literate programming itself with a small bootstrap
code.  This document is Ulquikit's literate source code.

To compile _and run_ Ulquikit, the following dependencies are required:

* http://asciidoctor.org[AsciiDoctor]
* http://racket-lang.org[Racket]

Ulquikit contains 2 parts:

* Bootstrap part: small and straightforward, consists of several Racket files
  to extract source code and documents from all AcsciiDoc files is +src/+
  directory of Ulquikit project.

* Main part: this file.

Let's dive into some terminology first

== Terminology

* A *code block* is an AsciiDoc code block.

* A *snippet* is a code block with Ulquikit-defined title and delimiter
  +----+.  By default, a code block title that starts +file::+ and +code::+
  defines a _file snippet_ and _code snippet_, respectively:

** A *file snippet* is a snippet producing a source file.
** A *code snippet* is a snippet storing source code that can be included into
   other snippets.

== Bootstrap

The two most important files from Bootstrap part are +generate-src.rkt+ and
+generate-docs.rkt+.  Others are to declare utility functions.

=== +bootstrap/generate-src.rkt+

* Looks for and saves all AsciiDoc code blocks
  ** If a block starts with +file::+ it's a file name
  ** If a block starts with +code::+: it's a code block name
  ** Otherwise, ignore the block.

* For each file block, looks for +;; include::<name>+ and recursively replaces
  that line with the corresponding block.  Proper indentation is inserted.
  Invalid ++<name>++s are considered error.  Then writes its contents to the
  corresponding file in +ulquikit/generated-src+.

=== +bootstrap/generate-docs.rkt+

Simply uses AsciiDoctor to generate docs to +ulquikit/generated-docs+.

== Main program

The best way to use Ulquikit is to start with some commands.  Let's define how
commands work first:

=== Commands

* Each command is a Racket module defined in +commands/+ directory, with the
  base file name as command name.
+
E.g. +commands/new-project.rkt+ is for +ulqui new-project+ command.

* Each module implementing a command must export a function with the name
  +run+.  Arguments passing through +run+ are actual command line arguments
  passing to the command.
+
Named arguments are translated into Racket's keyword arguments.
+
E.g.
+
  ** Executing +ulqui generate-src+ calls ++commands/generate-src++'s +(run)+.
  ** Executing +ulqui generate-src some-file+ calls
     ++commands/generate-src++'s +(run "some-file")+.
  ** Executing +ulqui generate-src --from file1 --to file2+ calls
     ++commands/generate-src++'s +(run #:from "file1" #:to "file2")+.

* All commands must import +command-core.rkt+ (relative to command directory:
  +../command-core.rkt+).

* All commands must export a +help+ function returning a string, which serves
  as documentation for that command when running from the command line with
  +ulqui command-name --help+ or +ulqui help command-name+.

==== Core functions to implement commands

.file::command-core.rkt
[source,racket,linenums]
----
;; include::license-header

#lang rackjure

(require srfi/1)

(require "utils/string.rkt")

(provide (all-defined-out))

(module+ test
  (require rackunit))

(define (display-command title)
  (displayln (str "----> " title)))

(define (run-help command)
  (eval `(local-require ,(str command ".rkt")))
  (eval '(help)))

;; include::command/parse-command-args

;; include::command/run-command

----

Two of the most important functions in +command-core+ module are
+run-command+ and +parse-command-args+.

+parse-command-args+ will transform command line arguments into a list of
appropriate keywords and values.

.code::command/parse-command-args
[source,racket,linenums]
----
;; #lang racket

(define is-argument? #λ(not (string-starts-with? % "-")))

(module+ test
  (check-equal? (is-argument? "")     #t)
  (check-equal? (is-argument? "a")    #t)
  (check-equal? (is-argument? "-a")   #f)
  (check-equal? (is-argument? "--a")  #f)
  (check-equal? (is-argument? "-")    #f))

(define is-option? #λ(not (is-argument? %)))

(module+ test
  (check-equal? (is-option? "")     #f)
  (check-equal? (is-option? "a")    #f)
  (check-equal? (is-option? "-a")   #t)
  (check-equal? (is-option? "--a")  #t)
  (check-equal? (is-option? "-")    #t))

(define parse-keyword
  #λ(string->keyword (~>> (string->list %)
                       (drop-while (λ (ch) (eq? #\- ch)))
                       list->string)))

(module+ test
  (check-equal? (parse-keyword "-h")      '#:h)
  (check-equal? (parse-keyword "--help")  '#:help)
  (check-equal? (parse-keyword "---help") '#:help))

(define (parse-command-args args)
  (let parse ([last-keyword null]
              [args         (string-split args " ")]
              [result       '()])
    (if (empty? args)
        (if (null? last-keyword)
            result
            (append result (list (list last-keyword #t))))
        (let* ([current-arg (first args)]
               [more        (rest args)]

               [next-keyword (if (is-argument? current-arg)
                                 null
                                 (parse-keyword current-arg))]
               [arg/converted (if (is-argument? current-arg)
                                  (if-let [value (string->number current-arg)]
                                    value
                                    current-arg)
                                  (parse-keyword current-arg))]
               [next-result-value
                (or (and (is-argument? current-arg)
                         (or (and (null? last-keyword)
                                  (list arg/converted))
                             (list (list last-keyword arg/converted))))

                    (and (is-option? current-arg)
                         (or (and (null? last-keyword)
                                  '())
                             (list (list last-keyword #t)))))])
          (parse next-keyword
                 more
                 (append result next-result-value))))))

(module+ test
  (check-equal? (parse-command-args "") '())

  (check-equal? (parse-command-args "hello-world")
                '("hello-world"))

  (check-equal? (parse-command-args "hello world")
                '("hello" "world"))

  (check-equal? (parse-command-args "--help")
                '([#:help #t]))

  (check-equal? (parse-command-args "hello --help")
                '("hello" [#:help #t]))

  (check-equal? (parse-command-args "--help hello")
                '([#:help "hello"]))

  (check-equal? (parse-command-args "hello world --help --set-tab 4")
                '("hello" "world"
                  [#:help #t]
                  [#:set-tab 4])))

----


+run-command+ the result of parse-command-args and perform the actual call to
+run+ function of the module implementing the command.

.code::command/run-command
[source,racket,linenums]
----
;; (define (run-command . arguments)
;;   (void)
;;   )
----

==== Built-in commands

===== +generate-src+

.file::commands/generate-src.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")

(require "../utils/path.rkt")
(require "../utils/string.rkt")

;; (provide run
;;          help)

(module+ test
  (require rackunit))

;; include::commands/generate-src/run

;; include::commands/generate-src/help

----

By default, +ulqui generate-src+ extracts source code from
+<project-root>/src+ and output to +<project-root>/generated-src+, so the
+run+ function takes 2 keyword arguments with default values like so:

* +#:from+, default to +"src"+, and
* +#:to+, default to +"generated-src"+

.code::commands/generate-src/run
[source,racket,linenums]
----
;; #lang racket

;; include::create-snippet

;; include::extract-snippets

;; (define (run #:from [from "src"]
;;              #:to   [to   "generated-src"])
;;   (display-command "generate-src")
;;   (~> (extract-snippets from)
;;     (include-file-snippets)
;;     (write-snippets-to-files to)))

----

+extract-snippets+ will

* find all AsciiDoc files in a directory (argument: +dir+),
* extract all AsciiDoc code snippet with titles and return them as hashes with
  +create-snippet+.

+extract-snippets+ relies on +extract-snippet+, which only extracts from one file
at a time.

.code::extract-snippets
[source,racket,linenums]
----
;; lang racket

;; include::extract-snippet

;; (define (extract-snippets from-dir)
;;   (for/fold ([snippet {}])
;;       ([file (list-all-adocs (standardize-path from-dir))])
;;     (dict-merge snippet (extract-snippet file))))

----

The way +extract-snippet+ works is very simple:

* It will first read the content of a file and break it into lines while
  preserving line numbers (thus the call to +string-split+ with +#:trim? #f+).

* Iterate through each line, one by one

* If the current line is an AsciiDoc code block delimiter (i.e. +----+), since
  we only care about snippet, there are several posibilities:

** if we are already inside a snippet (when +inside-snippet+ is +#t+), it
   means the snippet is finished ⇨ reset +inside-snippet+ to +#f+;

** if we are outside a snippet (when +inside-snippet+ is +#f+) and the
   previous line does not define a new snippet (i.e. it doesn't start with
   +file::+ or +code::+ or user-defined ones), ignore this case;

** if we are outside a snippet (when +inside-snippet+ is +#f+) and the
   previous line does define a new snippet (starting with +file::+ or +code::+
   or user-defined ones) ⇨
   
*** set +inside-snippet+ to +#t+

*** save the snippet name, and

*** save the line number marking the beginning of the snippet;

* If current line is _not_ an AsciiDoc code block delimiter: update snippet
  content if +inside-snippet+ is +#t+ and ignore this line otherwise.


.code::extract-snippet
[source,racket,linenums]
----
(define is-block-delimiter?
  #λ(regexp-match? #rx"^----( *)$" %))

(module+ test
  (check-equal? (is-block-delimiter? "----")    #t)
  (check-equal? (is-block-delimiter? " ----")   #f)
  (check-equal? (is-block-delimiter? "---- ")   #t)
  (check-equal? (is-block-delimiter? "----  ")  #t)
  (check-equal? (is-block-delimiter? "----a")   #f))

;; (define (extract-snippet path)
;;   (let* ([file-content (read-file path)]
;;          [lines        (string-split file-content "\n" #:trim? #f)]

;;          [snippets        (box {})]

;;          [prev-line       (box "")]

;;          [snippet-type    (box null)]
;;          [snippet-content (box "")]
;;          [snippet-name    (box "")]
;;          [snippet-linenum (box 0)]
;;          [inside-snippet  (box #f)])

;;     (for ([line-num    (in-naturals 1)]
;;           [line        (in-list lines)])
;;       (if (is-block-delimiter? line)
;;           (cond [(unbox inside-snippet)
;;                  (box-cas! inside-snippet #f)
;;                  (box-swap! snippets
;;                             add-snippets
;;                             (create-snippet #:type (unbox snippet-type)
;;                                             #:name (unbox snippet-name)
;;                                             #:linenum (unbox snippet-linenum)
;;                                             #:content (unbox snippet-content)))]

;;                 [else
;;                  (when (is-block-title? (unbox prev-line))
;;                    (box-cas! inside-snippet #t)

;;                    (box-cas! snippet-type (get-snippet-type line))
;;                    (box-cas! snippet-name (get-snippet-name line))
;;                    (box-cas! snippet-content "")
;;                    (box-cas! snippet-linenum (dec line)))])
;;           (when (inside-snippet)
;;             (box-swap! snippet-content string-append "\n" line)))

;;       ;; Always update previous line
;;       (box-cas! prev-line line))

;;     (unbox snippets)))

;; (module+ test
;;   (let* ([temp-dir (get-relative-path (get-temp-dir)
;;                                       "./ulqui-extract-snippets/inside")]

;;          [expected-code-snippets
;;           {"main-program" (string-join
;;                            '(";; include::utils"
;;                              ""
;;                              "(module+ main"
;;                              "  (displayln (string-reverse \"¡Hola mundo!\")))"
;;                              "")
;;                            "\n")
;;            "use-rackjure" (string-join
;;                            '("#lang rackjure"
;;                              "(current-curly-dict hash)")
;;                            "\n")
;;            "license-header" ";; Just a sample license header."
;;            "utils" ";; include::utils-string"
;;            "utils-string" (string-join
;;                            '("(define (string-reverse str)"
;;                              "  (~> (string->list str)"
;;                              "    reverse"
;;                              "    list->string))")
;;                            "\n")}]

;;          [expected-file-snippets
;;           {"/tmp/tmp.rkt" (string-join
;;                            '(";; include::license-header"
;;                              ""
;;                              ";; include::use-rackjure"
;;                              ""
;;                              ";; include::main-program"
;;                              ""
;;                              "== Main program"
;;                              "")
;;                            "\n")}]

;;          [file-list '("Main"
;;                       "License"
;;                       "inside/Utils"
;;                       "inside/Utils-String")]
;;          [source-files (for/list ([name (in-list file-list)])
;;                          (get-relative-path (format "~a./~a.adoc"
;;                                                     temp-dir
;;                                                     name)))]
;;          [content
;;           {"Main" (string-join
;;                    '("= A document"
;;                      ""
;;                      "Just a hello world program"
;;                      ""
;;                      ".file::/tmp/tmp.rkt"
;;                      "[source,racket,linenums]"
;;                      "----"
;;                      (expected-file-snippets "/tmp/tmp.rkt")
;;                      "----"
;;                      ".code::main-program"
;;                      "[source,racket,linenums]"
;;                      "----"
;;                      (expected-code-snippets "main-program")
;;                      "----"
;;                      ".code::use-rackjure"
;;                      "[source]"
;;                      "----"
;;                      (expected-code-snippets "use-rackjure")
;;                      "----"
;;                      "")
;;                    "\n")
;;            "License" (string-join
;;                       '("= License header"
;;                         ""
;;                         ".code::license-header"
;;                         "[source,racket]"
;;                         "----"
;;                         (expected-code-snippets "license-header")
;;                         "----")
;;                       "\n")
;;            "inside/Utils" (string-join
;;                            '("= Utils"
;;                              ""
;;                              "Right now, we just want to include string utililities."
;;                              ""
;;                              ".code::utils"
;;                              "[source,racket,linenums]"
;;                              "----"
;;                              (expected-code-snippets "utils")
;;                              "----")
;;                            "\n")
;;            "inside/Utils-String" (string-join
;;                                   '("= String Utilities"
;;                                     ""
;;                                     ".code::utils-string"
;;                                     "[source,racket,linenums]"
;;                                     "----"
;;                                     (expected-code-snippets "utils-string")
;;                                     "----")
;;                                   "\n")}])
;;     (with-handlers ([exn:fail? #λ(remove-dir temp-dir)])
;;       (remove-dir temp-dir)
;;       (create-dir temp-dir)
;;       (for ([(filename content) (in-hash content)])
;;         (let ([path (format "~a./~a.adoc" temp-dir filename)])
;;           (display-to-file content path)))

;;       (let* ([snippets (extract-snippet temp-dir)]
;;              [code-snippet (snippets 'code)]
;;              [file-snippet (snippets 'file)])
;;         (check-equal? code-snippet expected-code-snippets)
;;         (check-equal? file-snippet expected-file-snippets))
;;       (remove-dir temp-dir))))
----

Each is snippet is stored with the following format:

[source,racket,linenums]
----
{'type snippet-type          <1>
 'name snippet-name          <2>
 'linenum line-number        <3>
 'content snippet-content}   <4>
----
<1> is either +'file+ or +'code+
<2> is the name of the snippet; e.g. snippet with title +file::something+ has
+something+ as its name
<3> is the line number from the literate source code from where the snippet is
extracted
<4> is the content of the code snippet, i.e. which is surrounded by +----+ in
AsciiDoc format

Thus, +create-snippet+ is implemented as followed:

.code::create-snippet
[source,racket,linenums]
----
;; #lang racket

(define (create-snippet #:type type
                        #:name name
                        #:linenum linenum
                        #:content content)
  (let ([type (if (symbol? type)
                  type
                  (string->symbol type))]
        [name (if (symbol? name)
                  name
                  (string->symbol name))])
    {'type type
     'name name
     'linenum linenum
     'content content}))

(module+ test
  (check-equal? (create-snippet #:type 'file
                                #:name 'hello-world
                                #:linenum 10
                                #:content "Hmm")
                {'type 'file
                 'name 'hello-world
                 'linenum 10
                 'content "Hmm"})
  (check-equal? (create-snippet #:type "string"
                                #:name "string"
                                #:linenum 100
                                #:content "string")
                {'type 'string
                 'name 'string
                 'linenum 100
                 'content "string"}))

----


=== Utility functions

See link:Utilities.html[Utilities].

=== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

=== License header

Of course, since Ulquikit is distributed under the terms of GPLv3, the license
header is necessary.

.code::license-header
[source,racket]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014 Nguyễn Hà Dương <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----
