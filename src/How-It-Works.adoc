= Ulquikit - How it works
:Author: Nguyễn Hà Dương (cmpitg)
:Email: <cmpitg@gmail.com>
:toc: left
:toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Ulquikit is written in literate programming itself with a small bootstrap
code.  This document is Ulquikit's literate source code.

To compile _and run_ Ulquikit, the following dependencies are required:

* http://asciidoctor.org[AsciiDoctor]
* http://racket-lang.org[Racket]

Ulquikit contains 2 parts:

* Bootstrap part: small and straightforward, consists of several Racket files
  to extract source code and documents from all AcsciiDoc files in +src/+

** To generate source code, run +src/bootstrap/generate-src.rkt+

** To generate documentation, run +src/bootstrap/generate-docs.rkt+

* Main part: this file.

Let's dive into some terminology first

== Terminology

* A *code block* is an AsciiDoc code block.

* A *snippet* is a code block with Ulquikit-defined title and delimiter
  +----+.  By default, a code block title that starts +file::+ and +code::+
  defines a _file snippet_ and _code snippet_, respectively:

** A *file snippet* is a snippet producing a source file.
** A *code snippet* is a snippet storing source code that can be included into
   other snippets.

== Extracting and including snippets

Ulquikit works by searching for all AsciiDoc documents inside
+<project-root>/src+ directory, building a database of snippets, including
them into each other if necessary, then generating documentation and source
code.  Hence, the following functions are probably the most interesting ones:

* +extract-snippets-from-file+, which helps extract snippets from a file
* +include-snippets+, which helps include snippets into each other

Let's talk about +extract-snippets-from-file+ first:

=== +extract-snippet+

The first thing to do is probably to decide how snippets are stored.  This is
very important since every change made to this data structure would affect
code later one.

Each snippet is a hash with following format:

[[snippet-format]]
[source,racket,linenums]
----
{'type snippet-type          <1>
 'name snippet-name          <2>
 'linenum line-number        <3>
 'content snippet-content}   <4>
----
<1> is either +'file+ or +'code+
<2> is the name of the snippet; e.g. snippet with title +file::something+ has
+something+ as its name.  Note that snippet name is _a string_.
<3> is the line number from the literate source code from where the snippet is
extracted
<4> is the content of the code snippet, i.e. which is surrounded by +----+ in
AsciiDoc format

NOTE: Snippets should never be created by directly by using hash.  They should
be created with <<func/create-snippet,+create-snippet+>>.

Thus, +create-snippet+ is simply implemented as followed:

[[func/create-snippet]]
.code::create-snippet
[source,racket,linenums]
----
;; #lang racket

(define (create-snippet #:type type
                        #:name name
                        #:linenum linenum
                        #:content content)
  (let ([type (if (symbol? type)
                  type
                  (string->symbol type))]
        [name (if (symbol? name)
                  (symbol->string name)
                  name)])
    {'type type
     'name name
     'linenum linenum
     'content content}))

(module+ test
  (check-equal? (create-snippet #:type 'file
                                #:name 'hello-world
                                #:linenum 10
                                #:content "Hmm")
                {'type 'file
                 'name "hello-world"
                 'linenum 10
                 'content "Hmm"})
  (check-equal? (create-snippet #:type "string"
                                #:name "string"
                                #:linenum 100
                                #:content "string")
                {'type 'string
                 'name "string"
                 'linenum 100
                 'content "string"}))

----

Now the helper +create-snippet+ is ready.  Let's move on to
+extract-snippets-from-file+.

+extract-snippets-from-file+ needs to determine whether _a line in a code
block_ belongs to a _code snippet_, or _file snippet_, or none of those; then
extracts the content of the code block and store it if necessary.  Let's have
a look at 3 types of code block to see how we could tackle this problem:

* A _code snippet_ has the following format:
+
[listing]
..........
.code::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........

* A _file snippet_ shares the same structure as a _code snippet_:
+
[listing]
..........
.file::title-of-the-code-block  <1>
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>
..........

* A non-snippet code block is any block without +code::...+ or +file::...+ as
  its title:
+
[listing]
..........
[source]                        <2>
----                            <3>
Content of the code block
----                            <4>

....                            <3>
This is a literal block
....                            <4>
..........

<1> block title
<2> block type
<3> block delimiter
<4> block delimiter

As we can clearly see from the 3 examples, _code snippets_ and _file snippets_
could be determined by checking 2^nd^ previous line from block delimiter to
see if it starts with +.file::+ or +.code::+.  Everything between the 2
delimiters is stored as the content of the snippet.

Hence, we have the following algorithm for +extract-snippets-from-file+:

* Read the content of a file

* Break the content into lines preserving line numbers (call +string-split+
  with +#:trim? #f+).

* For each line:

** If we're already inside a snippet:

*** Complete a snippet and add it to snippet list if current line is a block
    delimiter (i.e. +----+)

*** Add current line to the current snippet's content if current line is not a
    block delimiter

** If we're outside a snippet, we only care if current line is a block
   delimiter (i.e. +----+):

*** If this block has a title that marks the beginning of a snippet (i.e. the
    2^nd^ previous line starts with +.file::+ or +.code::+), extract snippet
    name and add a new snippet.  Otherwise

*** If this block does not mark the beginning of a snippet, ignore it.

.code::extract-snippets-from-file
[source,racket,linenums]
----
;; include::extract-snippets-from-file-helpers

(define (extract-snippets-from-file path)
  (let* ([file-content (read-file path)]
         [lines        (string-split file-content "\n" #:trim? #f)]

         [snippets        (box {'file {}
                               'code {}})]

         [prev-prev-line  (box "")]
         [prev-line       (box "")]

         [snippet-type    (box null)]
         [snippet-lines   (box '())]
         [snippet-name    (box "")]
         [snippet-linenum (box 0)]
         [inside-snippet  (box #f)])

    (for ([line-num    (in-naturals 1)]
          [line        (in-list lines)])

      (cond [(and (unbox inside-snippet)
                  (not (is-block-delimiter? line)))

             (box-swap! snippet-lines append (list line))]

            [(and (unbox inside-snippet)
                  (is-block-delimiter? line))

             (box-set! inside-snippet #f)
             (box-swap! snippets
                        add-snippets
                        (create-snippet #:type (unbox snippet-type)
                                        #:name (unbox snippet-name)
                                        #:linenum (unbox snippet-linenum)
                                        #:content (string-join (unbox snippet-lines)
                                                               "\n")))]
            [(is-block-delimiter? line)

             (when (is-block-title? (unbox prev-prev-line))
               (box-set! inside-snippet #t)

               (box-set! snippet-type (get-snippet-type (unbox prev-prev-line)))
               (box-set! snippet-name (get-snippet-name (unbox prev-prev-line)))
               (box-set! snippet-lines '())
               (box-set! snippet-linenum (dec line-num)))])

      ;; Always update previous line
      (box-set! prev-prev-line (unbox prev-line))
      (box-set! prev-line      line))

    (unbox snippets)))

----

Of course, for +extract-snippets-from-file+ to function, the following helpers are
necessary:

.code::extract-snippets-from-file-helpers
[source,racket,linenums]
----
(define is-block-delimiter?
  #λ(regexp-match? #rx"^----( *)$" %))

(module+ test
  (check-equal? (is-block-delimiter? "----")    #t)
  (check-equal? (is-block-delimiter? " ----")   #f)
  (check-equal? (is-block-delimiter? "---- ")   #t)
  (check-equal? (is-block-delimiter? "----  ")  #t)
  (check-equal? (is-block-delimiter? "----a")   #f))

(define is-block-title?
  #λ(regexp-match? #rx"^\\.(file|code)::" %))

(module+ test
  (check-equal? (is-block-title? ".file::something")       #t)
  (check-equal? (is-block-title? ".file::something else")  #t)
  (check-equal? (is-block-title? ".file::")                #t)
  (check-equal? (is-block-title? ".file:something")        #f))

(define get-snippet-type
  #λ(~> (string-rest %)
      (string-split "::")
      (list-ref 0)
      string->symbol))

(module+ test
  (check-equal? (get-snippet-type ".file::")  'file)
  (check-equal? (get-snippet-type ".code::")  'code))

(define get-snippet-name
  #λ(~> (string-rest %)
      (string-split "::")
      (append '(""))
      (list-ref 1)))

(module+ test
  (check-equal? (get-snippet-name ".file::")     "")
  (check-equal? (get-snippet-name ".code::")     "")
  (check-equal? (get-snippet-name ".file::abc")  "abc")
  (check-equal? (get-snippet-name ".code::a b")  "a b"))

(define (add-snippets snippets snippet)
  (let* ([type (snippet 'type)]
         [name (snippet 'name)]

         [snippets/typed         (snippets type)]
         [snippets/typed/updated (snippets/typed name snippet)])
    (snippets type snippets/typed/updated)))

(module+ test
  (check-equal? (add-snippets {'file {}
                               'code {}}
                              (create-snippet #:type 'file
                                              #:name 'hello
                                              #:linenum 10
                                              #:content "Something"))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'content "Something"}}
                 'code {}})

  (check-equal? (add-snippets {'file {"hello" {'type 'file
                                               'name "hello"
                                               'linenum 10
                                               'content "Something"}}
                               'code {}}
                              (create-snippet #:type 'code
                                              #:name 'say-something
                                              #:linenum 100
                                              #:content "Something else"))
                {'file {"hello" {'type 'file
                                 'name "hello"
                                 'linenum 10
                                 'content "Something"}}
                 'code {"say-something" {'type 'code
                                         'name "say-something"
                                         'linenum 100
                                         'content "Something else"}}}))

----

As a result, +extract-snippets+, which extracts snippets from all AsciiDoc
documents in a directory recursively, makes use of
+extract-snippets-from-file+ to function.  +extract-snippets+ takes a path and
return a hash of following format:

[source,racket]
----
{'file file-snippets-hash
 'code code-snippets-hash}
----

+file-snippets-hash+ and +code-snippets-hash+ follow <<snippet-format,snippet
format>> defined above.

.code::extract-snippets
[source,racket,linenums]
----
;; include::extract-snippets-from-file

(define (extract-snippets from-dir)
  (for/fold ([snippet {}])
      ([file (list-all-adocs (standardize-path from-dir))])
    (dict-merge snippet (extract-snippets-from-file file))))

(module+ test
  (let* ([temp-dir (get-relative-path (get-temp-dir)
                                      "./ulqui-extract-snippets")]

         [expected-code-snippets
          {"main-program" (string-join
                           '(";; include::utils"
                             ""
                             "(module+ main"
                             "  (displayln (string-reverse \"¡Hola mundo!\")))"
                             "")
                           "\n")
           "use-rackjure" (string-join
                           '("#lang rackjure"
                             "(current-curly-dict hash)")
                           "\n")
           "license-header" ";; Just a sample license header."
           "utils" ";; include::utils-string"
           "utils-string" (string-join
                           '("(define (string-reverse str)"
                             "  (~> (string->list str)"
                             "    reverse"
                             "    list->string))")
                           "\n")}]

         [expected-file-snippets
          {"/tmp/tmp.rkt" (string-join
                           '(";; include::license-header"
                             ""
                             ";; include::use-rackjure"
                             ""
                             ";; include::main-program"
                             ""
                             "== Main program"
                             "")
                           "\n")}]

         [file-list '("Main"
                      "License"
                      "inside/Utils"
                      "inside/Utils-String")]
         [source-files (for/list ([name (in-list file-list)])
                         (get-relative-path (format "~a./~a.adoc"
                                                    temp-dir
                                                    name)))]
         [content
          {"Main" (string-join
                   (list "= A document"
                         ""
                         "Just a hello world program"
                         ""
                         ".file::/tmp/tmp.rkt"
                         "[source,racket,linenums]"
                         "----"
                         (expected-file-snippets "/tmp/tmp.rkt")
                         "----"
                         ".code::main-program"
                         "[source,racket,linenums]"
                         "----"
                         (expected-code-snippets "main-program")
                         "----"
                         ".code::use-rackjure"
                         "[source]"
                         "----"
                         (expected-code-snippets "use-rackjure")
                         "----"
                         "")
                   "\n")
           "License" (string-join
                      (list "= License header"
                            ""
                            ".code::license-header"
                            "[source,racket]"
                            "----"
                            (expected-code-snippets "license-header")
                            "----")
                      "\n")
           "inside/Utils" (string-join
                           (list "= Utils"
                                 ""
                                 "Right now, we just want to include string utililities."
                                 ""
                                 ".code::utils"
                                 "[source,racket,linenums]"
                                 "----"
                                 (expected-code-snippets "utils")
                                 "----")
                           "\n")
           "inside/Utils-String" (string-join
                                  (list "= String Utilities"
                                        ""
                                        ".code::utils-string"
                                        "[source,racket,linenums]"
                                        "----"
                                        (expected-code-snippets "utils-string")
                                        "----")
                                  "\n")}])
    (with-handlers ([exn:fail? #λ(remove-dir temp-dir)])
      (remove-dir temp-dir)
      (create-dir (get-relative-path temp-dir
                                     "./inside"))
      (for ([(filename content) (in-hash content)])
        (let ([path (get-relative-path temp-dir
                                       (format "./~a.adoc" filename))])
          (display-to-file content path)))

      (let* ([snippets (extract-snippets temp-dir)]
             [code-snippet (snippets 'code)]
             [file-snippet (snippets 'file)])

        (for ([(name snippet) code-snippet])
          (check-equal? (snippet 'content)
                        (expected-code-snippets name)))

        (for ([(name snippet) file-snippet])
          (check-equal? (snippet 'content)
                        (expected-file-snippets name))))
      (remove-dir temp-dir))))
----

After +extract-snippets+, the next important function is +include-snippets+,
which is use to include snippets to each other.  Let's see how we could
implement it.

=== +include-snippets+

+include-snippets+ should take 2 arguments: a hash containing all snippets,
and the snippet which needs to be checked and included.  Thus this function
has the following signature: +(include-snippets snippets target)+
+include-snippets+ working by browsing its content, one line at a time, then
replace the line with +include+ directive with the corresponding _code
snippet_.  If no snippet is found, leave that line as-is.

=== +generate-src+

.file::commands/generate-src.rkt
[source,racket,linenums]
----
;; include::license-header

;; include::use-rackjure

(require "../command-core.rkt")

(require "../utils/utils.rkt")
(require "../utils/path.rkt")
(require "../utils/string.rkt")

;; (provide run
;;          help)

(module+ test
  (require rackunit))

;; include::commands/generate-src/run

;; include::commands/generate-src/help

----

By default, +ulqui generate-src+ extracts source code from
+<project-root>/src+ and output to +<project-root>/generated-src+, so the
+run+ function takes 2 keyword arguments with default values like so:

* +#:from+, default to +"src"+, and
* +#:to+, default to +"generated-src"+

.code::commands/generate-src/run
[source,racket,linenums]
----
;; #lang racket

;; include::create-snippet

;; include::extract-snippets

;; (define (run #:from [from "src"]
;;              #:to   [to   "generated-src"])
;;   (display-command "generate-src")
;;   (~> (extract-snippets from)
;;     (include-file-snippets)
;;     (write-snippets-to-files to)))

----

== Commands

* Each command is a Racket module defined in +commands/+ directory, with the
  base file name as command name.
+
E.g. +commands/new-project.rkt+ is for +ulqui new-project+ command.

* Each module implementing a command must export a function with the name
  +run+.  Arguments passing through +run+ are actual command line arguments
  passing to the command.
+
Named arguments are translated into Racket's keyword arguments.
+
E.g.
+
  ** Executing +ulqui generate-src+ calls ++commands/generate-src++'s +(run)+.
  ** Executing +ulqui generate-src some-file+ calls
     ++commands/generate-src++'s +(run "some-file")+.
  ** Executing +ulqui generate-src --from file1 --to file2+ calls
     ++commands/generate-src++'s +(run #:from "file1" #:to "file2")+.

* All commands must import +command-core.rkt+ (relative to command directory:
  +../command-core.rkt+).

* All commands must export a +help+ function returning a string, which serves
  as documentation for that command when running from the command line with
  +ulqui command-name --help+ or +ulqui help command-name+.

=== Core functions to implement commands

.file::command-core.rkt
[source,racket,linenums]
----
;; include::license-header

#lang rackjure

(require srfi/1)

(require "utils/string.rkt")

(provide (all-defined-out))

(module+ test
  (require rackunit))

(define (display-command title)
  (displayln (str "----> " title)))

(define (run-help command)
  (eval `(local-require ,(str command ".rkt")))
  (eval '(help)))

;; include::command/parse-command-args

;; include::command/run-command

----

Two of the most important functions in +command-core+ module are
+run-command+ and +parse-command-args+.

+parse-command-args+ will transform command line arguments into a list of
appropriate keywords and values.

.code::command/parse-command-args
[source,racket,linenums]
----
;; #lang racket

(define is-argument? #λ(not (string-starts-with? % "-")))

(module+ test
  (check-equal? (is-argument? "")     #t)
  (check-equal? (is-argument? "a")    #t)
  (check-equal? (is-argument? "-a")   #f)
  (check-equal? (is-argument? "--a")  #f)
  (check-equal? (is-argument? "-")    #f))

(define is-option? #λ(not (is-argument? %)))

(module+ test
  (check-equal? (is-option? "")     #f)
  (check-equal? (is-option? "a")    #f)
  (check-equal? (is-option? "-a")   #t)
  (check-equal? (is-option? "--a")  #t)
  (check-equal? (is-option? "-")    #t))

(define parse-keyword
  #λ(string->keyword (~>> (string->list %)
                       (drop-while (λ (ch) (eq? #\- ch)))
                       list->string)))

(module+ test
  (check-equal? (parse-keyword "-h")      '#:h)
  (check-equal? (parse-keyword "--help")  '#:help)
  (check-equal? (parse-keyword "---help") '#:help))

(define (parse-command-args args)
  (let parse ([last-keyword null]
              [args         (string-split args " ")]
              [result       '()])
    (if (empty? args)
        (if (null? last-keyword)
            result
            (append result (list (list last-keyword #t))))
        (let* ([current-arg (first args)]
               [more        (rest args)]

               [next-keyword (if (is-argument? current-arg)
                                 null
                                 (parse-keyword current-arg))]
               [arg/converted (if (is-argument? current-arg)
                                  (if-let [value (string->number current-arg)]
                                    value
                                    current-arg)
                                  (parse-keyword current-arg))]
               [next-result-value
                (or (and (is-argument? current-arg)
                         (or (and (null? last-keyword)
                                  (list arg/converted))
                             (list (list last-keyword arg/converted))))

                    (and (is-option? current-arg)
                         (or (and (null? last-keyword)
                                  '())
                             (list (list last-keyword #t)))))])
          (parse next-keyword
                 more
                 (append result next-result-value))))))

(module+ test
  (check-equal? (parse-command-args "") '())

  (check-equal? (parse-command-args "hello-world")
                '("hello-world"))

  (check-equal? (parse-command-args "hello world")
                '("hello" "world"))

  (check-equal? (parse-command-args "--help")
                '([#:help #t]))

  (check-equal? (parse-command-args "hello --help")
                '("hello" [#:help #t]))

  (check-equal? (parse-command-args "--help hello")
                '([#:help "hello"]))

  (check-equal? (parse-command-args "hello world --help --set-tab 4")
                '("hello" "world"
                  [#:help #t]
                  [#:set-tab 4])))

----


+run-command+ the result of parse-command-args and perform the actual call to
+run+ function of the module implementing the command.

.code::command/run-command
[source,racket,linenums]
----
;; (define (run-command . arguments)
;;   (void)
;;   )
----

== Utility functions

See link:Utilities.html[Utilities].

== Misc

.code::use-rackjure
[source,racket,linenums]
----
#lang rackjure

(current-curly-dict hash)
----

== License header

Of course, since Ulquikit is distributed under the terms of GPLv3, the license
header is necessary.

.code::license-header
[source,racket]
----
;;
;; This file is part of Ulquikit project.
;;
;; Copyright (C) 2014 Nguyễn Hà Dương <cmpitg AT gmailDOTcom>
;;
;; Ulquikit is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation, either version 3 of the License, or (at your option)
;; any later version.
;;
;; Ulquikit is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
;; details.
;;
;; You should have received a copy of the GNU General Public License along
;; with Ulquikit.  If not, see <http://www.gnu.org/licenses/>.
;;
----
