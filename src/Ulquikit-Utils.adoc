= Utilities for Ulquikit
:Author: Ha-Duong Nguyen (cmpitg)
:Email: <cmpitg@gmail.com>
// :toc: left
// :toclevels: 4
:numbered:
:icons: font
:source-highlighter: pygments
:pygments-css: class
:website: http://reference-error.org/projects/ulquikit

Below is the list of utilities/helpers that Ulquikit makes use of.  All of
them are written with simplicity and reusability in mind, while maintaining
relative good performance.

.file::utils.lisp
[source,lisp,linenums]
----
;; include::license-header

(defpackage #:ulqui/utils
  (:use :cl
        :alexandria
        :iterate
        :trivial-utf-8
        :cl-ppcre)
  (:export #:join-lines
           #:->keyword
           #:->string
           #:sethash
           #:read-file
           #:take-while
           #:drop-while
           #:full-path
           #:directorize-path
           #:file?
           #:write-file))

(defpackage #:ulqui/utils-tests
  (:use :cl
        :lisp-unit
        :ulqui/utils)
  (:import-from :alexandria :when-let))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Implementation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package #:ulqui/utils)

(defun join-lines (lines)
  "Joins a list of strings with newline as separator."
  (declare (list lines))
  (the string (format nil "~{~A~^~%~}" lines)))

(in-package #:ulqui/utils-tests)

(define-test test-join-lines
  (assert-equal "" (join-lines '()))
  (assert-equal "a" (join-lines '("a")))
  (assert-equal (format nil "a~%b") (join-lines '("a" "b")))
  (assert-equal (format nil "a~%b~%") (join-lines '("a" "b" ""))))

;; (run-tests '(test-join-lines))

(in-package #:ulqui/utils)

(defun directorize-path (path)
  "Turns `path' into a canonical directory pathname, i.e. suffixing it with
\"/\" if necessary."
  (declare ((or string pathname) path))
  (pathname (if (file? path)
                (format nil "~A/" path)
              path)))

(in-package #:ulqui/utils-tests)

(define-test test-directorize-path
  (assert-equal #p"/" (directorize-path "")
  (assert-equal #p"/tmp/" (directorize-path "/tmp")
  (assert-equal #p"/tmp/" (directorize-path "/tmp/")))))

(in-package #:ulqui/utils)

(defun ->keyword (val)
  "Converts a symbol or string into keyword."
  (declare ((or symbol string) val))
  (the keyword (etypecase val
                 (keyword val)
                 (symbol (intern (string-upcase (symbol-name val)) 'keyword))
                 (string (intern (string-upcase val) 'keyword)))))

(defun ->string (val)
  "Converts a symbol or keyword into string."
  (declare ((or symbol string) val))
  (the string (etypecase val
                (string val)
                ((or symbol keyword) (string-downcase (symbol-name val))))))

(in-package #:ulqui/utils)

(defun sethash (key hash value &rest args)
  "Conveniently combining `setf' and `gethash'.

`\(setf \(gethash o hash\) obj\)' ⬄ `\(sethash o hash obj\)'
`\(setf \(gethash o hash\) obj
      \(gethash a hash\) abj\)'
⬄
`\(sethash o hash obj
         a hash abj\)'
"
  (declare (hash-table hash))
  (unless (zerop (mod (length args) 3))
    (error "number of arguments must be divisible by 3."))

  (setf (gethash key hash) value)

  (unless (null args)
    (apply #'sethash (first args) (second args) (third args) (subseq args 3))))

(in-package #:ulqui/utils-tests)

(define-test test-macro-sethash
  (let ((hash (make-hash-table)))
    (sethash :first hash "hello")
    (sethash :second hash "world")
    (assert-equal "hello" (gethash :first hash))
    (assert-equal "world" (gethash :second hash))))

;; (run-tests '(test-macro-sethash))

(in-package #:ulqui/utils)

(defun file? (path)
  "Determines if path represents a file."
  (declare ((or string pathname) path))
  (the boolean
       (null (scan "/$" (namestring path)))))

(in-package #:ulqui/utils-tests)

(define-test test-file?
  (assert-true  (file? "tmp.txt"))
  (assert-true  (file? #p"tmp.txt"))
  (assert-false (file? "tmp.txt/"))
  (assert-false (file? #p"tmp.txt/")))

;; (run-tests '(test-file?))

(in-package #:ulqui/utils)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun read-file (path)
    "Reads a file as UTF-8 encoded string."
    (declare ((or string pathname) path))
    (with-open-file (in path :element-type '(unsigned-byte 8))
      (read-utf-8-string in :stop-at-eof t))))

(in-package #:ulqui/utils)

(defun write-file (path content)
  "Writes to a file."
  (declare ((or pathname string) path)
           (string content))
  (with-output-to-file (out path :if-exists :supersede)
    (format out "~A" content)))

(in-package #:ulqui/utils)

(defun take-while (fn xs)
  "Takes each `item' of `xs' from the beginning and builds a list until
`\(funcall fn item\)' returns `nil'.

E.g.

  \(take-while #'oddp '\(\)\)          ;; ⇨ '\(\)
  \(take-while #'oddp '\(2 3 4\)\)     ;; ⇨ '\(\)
  \(take-while #'evenp '\(2 2 4\)\)    ;; ⇨ '\(2 2 4\)
  \(take-while #'evenp '\(2 2 1 3\)\)  ;; ⇨ '\(2 2\)"
  (declare (function fn) (sequence xs))
  (the list (iterate (for x in xs)
                     (while (funcall fn x))
                     (collect x))))

(in-package #:ulqui/utils-tests)

(define-test test-take-while
  (assert-equal '()      (take-while #'oddp '()))
  (assert-equal '()      (take-while #'oddp '(2 3 4)))
  (assert-equal '(2 2 4) (take-while #'evenp '(2 2 4)))
  (assert-equal '(2 2)   (take-while #'evenp '(2 2 1 3))))

(in-package #:ulqui/utils)

(defun drop-while (fn xs)
  "Starting from the first item of `xs' that `\(funcall fn item\)' returns
`nil', builds a list with the rest of `xs'.

E.g.

  \(drop-while #'oddp '\(\)\)            ;; ⇨ '\(\)
  \(drop-while #'oddp '\(1 1 5 7\)\)     ;; ⇨ '\(\)
  \(drop-while #'oddp '\(1 2 5 2 3 4\)\) ;; ⇨ '\(2 3 4\)
  \(drop-while #'oddp '\(2 3 4\)\)       ;; ⇨ '\(2 3 4\)"
  (declare (function fn) (sequence xs))
  (the list (labels ((helper (xs)
                       (cond ((null xs)
                              (list))
                             ((not (funcall fn (first xs)))
                              xs)
                             (t
                              (helper (rest xs))))))
              (helper xs))))

(in-package #:ulqui/utils-tests)

(define-test test-drop-while
  (assert-equal '()      (drop-while #'oddp '()))
  (assert-equal '()      (drop-while #'oddp '(1 1 5 7)))
  (assert-equal '(2 3 4) (drop-while #'oddp '(1 1 5 2 3 4)))
  (assert-equal '(2 3 4) (drop-while #'oddp '(2 3 4))))

(in-package #:ulqui/utils)

(defun full-path (path)
  "Returns absolute path."
  (declare ((or string pathname) path))
  (uiop:merge-pathnames* path (cl-cwd:cwd)))

(in-package #:ulqui/utils)

(defun function-name (fsymbol)
  "Returns the name of a corresponding function as string."
  (declare (function fsymbol))
  (let ((name-tmp (nth 1 (split-sequence #\Space
                                         (format nil "~(~A~)" fsymbol)))))
    (subseq name-tmp 0 (1- (length name-tmp)))))

(in-package #:ulqui/utils-tests)

(define-test test-function-name
  (assert-equal "format"        (function-name #'format))
  (assert-equal "function-name" (function-name #'function-name)))

----
